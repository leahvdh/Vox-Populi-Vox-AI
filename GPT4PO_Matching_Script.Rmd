---
title: "GPT matching function"
author: "Leah von der Heyde, Max Lang"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stringr)
library(dplyr)
library(checkmate)
```

Load data

```{r}
#load("GPT_prompt_completion.RData") # if not in environment from running API script
```

# Create keywords to search for

TO DO: confirm final accepted keywords

```{r}
sequences <- c("SPD", "CDU/CSU","CDU", "CSU", "Union", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christ", "freie", "liberal", "Alternative", "links", "nicht", "ungültig", "Erststimme")
check_sequences <- c("nicht", "ungültig", "Erststimme")

# QUESTION: Change to "Die Linke" and "Linkspartei" and add "links/link" without those strings to flags?

# This list defines the categories for the parties. If at least two words (one each) of two different categories are in one sentence, that sentence gets flagged for manual checking.
sequences_list <- list(spd = c("SPD", "sozialdemokrat"),
                       gruene = c("Grüne", "B90", "Bündnis"),
                       union = c("CDU/CSU", "CDU", "CSU", "Union", "christ"),
                       fdp = c("FDP", "freie", "liberal"),
                       afd = c("AfD", "Alternative"),
                       linke = c("Linke", "links"))
```

# Match 1: Completions - Party Keywords

Create a function that
- checks whether completions_df$gpt3 contains any of the following strings:
c("SPD", "CDU", "CSU", "Union", "CDU/CSU", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christ", "freie", "liberal", "links", Alternative", "nicht", "ungültig", "Erststimme")
(case-insensitive, also partial strings, e.g. "sozialdemokratisch" und "sozialdemokraten"
should both be recognized by " * sozialdemokrat * ")

- stores all the matched strings per row in a new df and column: match_completions_df$matched; if there is no match, the column should remain empty but still store the respective row
- marks those rows that contain "Erststimme" OR "nicht" OR "ungültig" OR naming multiple parties OR having no keyword match by creating a column "check_manually" that takes the value 1 if any of these conditions are met
- also stores the following columns from the completions_df: "id" as "id" and "gpt3" as "completion"

NEW: Also flag NA rows!

## Function get_matches_vector

```{r}
#' get_matches_vector
#'
#' This function extracts matches from a column based on a set of keywords.
#'
#' @param keywords A character vector of keywords to search for.
#' @param column A character vector representing the column to search in.
#' @param delimiter A character string to use as a delimiter when collapsing the matches. Default is a space (" ").
#' @param replace_zero_length Logical indicating whether to replace zero-length matches (character(0L)) with NA. Default is TRUE.
#'
#' @return A character vector containing the matches found, collapsed using the specified delimiter.
#'
#' @examples
#' keywords <- c("keyword1", "keyword2", "keyword3")
#' completions_df <- data.frame(gpt3 = c("This is keyword1", "No match here", "Another keyword2 match"))
#' get_matches_vector(keywords, completions_df$gpt3)
#'


get_matches_vector <- function(keywords, column, delimiter = " ", replace_zero_length = TRUE) {
  assert_character(keywords, min.len = 1)
  assert_character(column)
  assert_character(delimiter, any.missing = FALSE, len = 1,)
  assert_logical(replace_zero_length, any.missing = FALSE, len = 1)
  
  keywords <- gsub("([.\\[\\{\\(\\*\\+\\?\\^\\$\\|\\\\])", "\\\\\\1", keywords, perl = TRUE)
  pattern <- paste0("\\b\\w*(", paste(keywords, collapse = "|"), ")\\w*\\b")
  matches <- str_extract_all(column, regex(pattern, ignore_case = TRUE))
  
  if (replace_zero_length) {
    matches <- lapply(matches, function(x) if(identical(x, character(0))) NA_character_ else x)
  }
  matches <- sapply(matches, paste, collapse = delimiter)
  return(matches)
}

get_matches_vector(keywords = sequences, column = completions_df$gpt3)

```

## Function get_check_value

```{r}
#' get_check_values
#'
#' This function checks if specific keywords are present in a set of matches.
#'
#' @param check_keywords A character vector of keywords to label for manual revision.
#' @param matches_split A character vector returned from the fucntion `get_matches_vector`
#' @param split_by A character string to use as a delimiter when splitting the matches. Default is a space (" ").
#'
#' @return A numeric vector indicating whether each keyword is present in each match. 1 indicates presence, 0 indicates absence.
#'
#' @examples
#' check_keywords <- c("Erststimme", "ungültig", "nicht")
#' matches <- get_matches_vector(keywords = sequences, column = completions_df$gpt3)
#' get_check_values(check_keywords, matches)
#'

get_check_values <- function(check_keywords, matches, split_by = " ") {
  assert_character(check_keywords, min.len = 1)
  assert_character(matches)
  assert_character(split_by, any.missing = FALSE, len = 1)

  check_manual_pattern <- paste0("\\b(", paste0(check_keywords, collapse = "|"), ")\\b")
  check_manual <- unlist(lapply(str_split(matches, split_by), function (x) {as.numeric(any(x %in% check_keywords))}))
  
  matches_split <- str_split(matches, pattern = " ")
  
  duplicated_party_vector <- unlist(lapply(lapply(lapply(lapply(matches_split, function(sentence) {
  sapply(sequences_list, function(category) {
    sum(str_count(tolower(sentence), regex(paste0("\\b\\w*(", paste(category, collapse = "|"), ")\\w*\\b"), ignore_case = TRUE)))
  })}), function (x) {x  != 0}), sum), function (x) {x > 1}))
  
  check_label <- ifelse(duplicated_party_vector == 1 | check_manual == 1, 1, 0)
  return(check_label)
}

get_check_values(c("Erststimme", "ungültig", "nicht"), get_matches_vector(keywords = sequences, column = completions_df$gpt3))
```

## Function create_match_completions_df

```{r}
#' create_match_completions_df
#'
#' This function creates a data frame with match completions based on given keywords and check keywords.
#'
#' @param df A data frame containing the original data.
#' @param keywords A character vector of keywords to search for.
#' @param check_keywords A character vector of keywords to mark words that trigger manual review.
#' @param ... Additional arguments passed to the underlying functions.
#'
#' @return A data frame with columns for ID, completion, matched values, and check manually values.
#'
#' @examples
#' keywords <- c("keyword1", "keyword2", "keyword3")
#' check_keywords <- c("Erststimme", "ungültig", "nicht")
#' completions_df <- data.frame(id = c(1, 2, 3), gpt3 = c("This is keyword1", "No match here", "Another keyword2 match"))
#' create_match_completions_df(completions_df, keywords, check_keywords)
#'

create_match_completions_df <- function (df, keywords, check_keywords, ...) {
  assert_data_frame(df, col.names = "named", types = c("numeric", "character", "character", "numeric") , ncols = 4)
  assert_character(keywords, min.len = 1)
  assert_character(check_keywords)
  
  matches <- get_matches_vector(keywords = sequences, column = df[["gpt3"]])
  check_manual <- get_check_values(check_keywords, matches)
  df <- data.frame(
    id = df[["id"]],
    completion = df[["gpt3"]],
    matched = matches,
    check_manually = check_manual
  )
  return(df)
}

match_completions <-  create_match_completions_df(completions_df, keywords = sequences, check_keywords = c("Erststimme", "ungültig", "nicht"))
```

# Match 2: Party Keywords - GLES Vote

Create a function that
- checks whether any of the strings in match_completions$matched match with GLES2017$vote (match rows via "id") and records this as 1 if matching, 0 otherwise.
- again, case insensitive and counting partial strings
- see below for what is considered a match (GLES2017$vote | match_completions$matched):

CDU/CSU | "CDU" OR "CSU" OR "CDU/CSU" OR "Union" OR "christ"
SPD | "SPD" OR "sozialdemokrat"
Bündnis 90/Die Grünen | "Grüne" OR "B90" OR "Bündnis" (besser "grün"?)
FDP | "FDP" OR "freie" OR "liberal"
Die Linke | "Linke" OR "links" (besser "link"?)
AfD | "AfD" OR "Alternative"

NEW
Andere Partei | "Andere Partei"
Ungültig gewählt | "ungültig gewählt"
Nicht gewählt | "nicht gewählt"

## Create mc_GLES2017
```{r}
# Joins matching and GLES datasets by ID to compare match with vote
mc_GLES2017 <- left_join(match_completions, GLES2017, by = c("id" = "lfdn"))
```

!!! MANUAL CHECKS NEED TO HAPPEN AT THIS STEP !!!

- Export dataset to csv.
- In excel, check:
-- check_manually: completions containing "nicht" or "ungültig" --> confirm and manipulate if necessary: "ungültig gewählt", "nicht gewählt"
-- check_manually: completions containing "Erststimme" --> manipulate Zweitstimme manually (insert suitable keyword from above)
-- vote: rows that have "Andere Partei" AND "NA" on keyword match --> check if completion has small party and manipulate Zweitstimme column if necessary: "Andere Partei"
-- check_manually: extract rows that have NA on keywords except Erststimme, check if they have Zweitstimme, re-sample again

!!! RE-SAMPLING LENGTHY COMPLETIONS NEEDS TO HAPPEN AT THIS STEP !!!

- Identify ID & iteration of missings
- Run API script again
- Merge with original dataset: replace specific rows!

# TO DO in code: add matches for "nicht", "ungültig" and "andere Partei" (andere Partei: might need to update matching script above too?)

## check_match help functions
```{r}
#' check_match_party (helper)
#'
#' This function checks for matches between the vote and matched column of the joined dataframe mc_GLES2017
#'
#' @param mc_GLES2017 The left-joined (by id and lfdn) dataframe of matches_completions and GLES2017
#'
#' @return A logical list indicating if vote and matched column match
#'
#' @examples
#' df <- data.frame(matched = c("This is CDU/CSU", "No match here", "Another SPD match"), vote = c("CDU/CSU", "FDP", "SPD"))
#' check_match_cdu_csu(df)
#' check_match_fdp(df)
#' check_match_spd(df)

# CDU/CSU 
check_match_cdu_csu <- function (mc_GLES2017) {
  pattern_cdu_csu <- paste0(".*", paste(c("CDU/CSU","CDU", "CSU", "Union", "christ"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_cdu_csu, ignore.case = TRUE)
}
# SPD
check_match_spd <- function (mc_GLES2017) {
  pattern_spd <- paste0(".*", paste(c("SPD", "sozialdemokrat"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_spd, ignore.case = TRUE)
}
# Grüne
check_match_gruene <- function (mc_GLES2017) {
  pattern_gruene <- paste0(".*", paste(c("Grüne", "B90", "Bündnis"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_gruene, ignore.case = TRUE)
}
# FDP 
check_match_fdp <- function (mc_GLES2017) {
  pattern_fdp <- paste0(".*", paste(c("FDP","freie", "liberal"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_fdp, ignore.case = TRUE)
}
# Die Linke
check_match_linke <- function (mc_GLES2017) {
  pattern_linke <- paste0(".*", paste(c("Linke","links"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_linke, ignore.case = TRUE)
}
# AFD
check_match_afd <- function (mc_GLES2017) {
  pattern_afd <- paste0(".*", paste(c("AfD","Alternative"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_afd, ignore.case = TRUE)
}
```

## Create match_voted outcome
```{r}
match_vote_outcome <-  case_when(
    mc_GLES2017$vote %in% "CDU/CSU" ~ check_match_cdu_csu(mc_GLES2017),
    mc_GLES2017$vote %in% "SPD" ~ check_match_spd(mc_GLES2017),
    mc_GLES2017$vote %in% "Bündnis 90/Die Grünen" ~ check_match_gruene(mc_GLES2017),
    mc_GLES2017$vote %in% "FDP" ~ check_match_fdp(mc_GLES2017),
    mc_GLES2017$vote %in% "Die Linke" ~ check_match_linke(mc_GLES2017),
    mc_GLES2017$vote %in% "AfD" ~ check_match_afd(mc_GLES2017)
)
match_vote_outcome[which(unlist(lapply(match_vote_outcome, is.null)))] <- NA

mc_GLES2017 %>% 
  mutate(match_vote_outcome = match_vote_outcome)

```