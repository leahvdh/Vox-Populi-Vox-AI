---
title: "GPT for Public Opinion: Matching Functions"
author: "Leah von der Heyde, Max Lang"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stringr)
library(dplyr)
library(checkmate)
```

Load data

```{r}
#load("GPT_prompt_completion.RData") # if not in environment from running API script
```

# Create keywords to search for

```{r}
sequences <- c("SPD", "CDU/CSU","CDU", "CSU", "Union", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christ", "freie", "liberal", "Alternative", "links", "nicht", "ungültig", "Erststimme")
check_sequences <- c("nicht", "ungültig", "Erststimme")

# QUESTION: Change to "Die Linke" and "Linkspartei" and add "links/link" without those strings to flags?

# This list defines the categories for the parties. If at least two words (one each) of two different categories are in one sentence, that sentence gets flagged for manual checking.
sequences_list <- list(spd = c("SPD", "sozialdemokrat"),
                       gruene = c("Grüne", "B90", "Bündnis"),
                       union = c("CDU/CSU", "CDU", "CSU", "Union", "christ"),
                       fdp = c("FDP", "freie", "liberal"),
                       afd = c("AfD", "Alternative"),
                       linke = c("Linke", "links"))
```

# Match 1: Completions - Party Keywords

Create a function that
- checks whether completions_df$gpt3 contains any of the following strings:
c("SPD", "CDU", "CSU", "Union", "CDU/CSU", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christ", "freie", "liberal", "links", Alternative", "nicht", "ungültig", "Erststimme")
(case-insensitive, also partial strings, e.g. "sozialdemokratisch" und "sozialdemokraten"
should both be recognized by " * sozialdemokrat * ")

- stores all the matched strings per row in a new df and column: match_completions_df$matched; if there is no match, the column should remain empty but still store the respective row
- marks those rows that contain "Erststimme" OR "nicht" OR "ungültig" OR naming multiple parties OR having no keyword match by creating a column "check_manually" that takes the value 1 if any of these conditions are met
- also stores the following columns from the completions_df: "id" as "id" and "gpt3" as "completion"

## Function get_matches_vector

```{r}
#' get_matches_vector
#'
#' This function extracts matches from a column based on a set of keywords.
#'
#' @param keywords A character vector of keywords to search for.
#' @param column A character vector representing the column to search in.
#' @param delimiter A character string to use as a delimiter when collapsing the matches. Default is a space (" ").
#' @param replace_zero_length Logical indicating whether to replace zero-length matches (character(0L)) with NA. Default is TRUE.
#'
#' @return A character vector containing the matches found, collapsed using the specified delimiter.
#'
#' @examples
#' keywords <- c("keyword1", "keyword2", "keyword3")
#' completions_df <- data.frame(gpt3 = c("This is keyword1", "No match here", "Another keyword2 match"))
#' get_matches_vector(keywords, completions_df$gpt3)
#'


get_matches_vector <- function(keywords, column, delimiter = " ", replace_zero_length = TRUE) {
  assert_character(keywords, min.len = 1)
  assert_character(column)
  assert_character(delimiter, any.missing = FALSE, len = 1,)
  assert_logical(replace_zero_length, any.missing = FALSE, len = 1)
  
  keywords <- gsub("([.\\[\\{\\(\\*\\+\\?\\^\\$\\|\\\\])", "\\\\\\1", keywords, perl = TRUE)
  pattern <- paste0("\\b\\w*(", paste(keywords, collapse = "|"), ")\\w*\\b")
  matches <- str_extract_all(column, regex(pattern, ignore_case = TRUE))
  
  if (replace_zero_length) {
    matches <- lapply(matches, function(x) if(identical(x, character(0))) NA_character_ else x)
  }
  matches <- sapply(matches, paste, collapse = delimiter)
  return(matches)
}

get_matches_vector(keywords = sequences, column = completions_df$gpt3)

```

## Function get_check_value

```{r}
#' get_check_values
#'
#' This function checks if specific keywords are present in a set of matches.
#'
#' @param check_keywords A character vector of keywords to label for manual revision.
#' @param matches_split A character vector returned from the fucntion `get_matches_vector`
#' @param split_by A character string to use as a delimiter when splitting the matches. Default is a space (" ").
#'
#' @return A numeric vector indicating whether each keyword is present in each match. 1 indicates presence, 0 indicates absence.
#'
#' @examples
#' check_keywords <- c("Erststimme", "ungültig", "nicht")
#' matches <- get_matches_vector(keywords = sequences, column = completions_df$gpt3)
#' get_check_values(check_keywords, matches)
#'

get_check_values <- function(check_keywords, matches, split_by = " ") {
  assert_character(check_keywords, min.len = 1)
  assert_character(matches)
  assert_character(split_by, any.missing = FALSE, len = 1)

  check_manual_pattern <- paste0("\\b(", paste0(check_keywords, collapse = "|"), ")\\b")
  check_manual <- unlist(lapply(str_split(matches, split_by), function (x) {as.numeric(any(x %in% check_keywords))}))
  
  matches_split <- str_split(matches, pattern = " ")
  
  duplicated_party_vector <- unlist(lapply(lapply(lapply(lapply(matches_split, function(sentence) {
  sapply(sequences_list, function(category) {
    sum(str_count(tolower(sentence), regex(paste0("\\b\\w*(", paste(category, collapse = "|"), ")\\w*\\b"), ignore_case = TRUE)))
  })}), function (x) {x  != 0}), sum), function (x) {x > 1}))
  
  check_label <- ifelse(duplicated_party_vector == 1 | check_manual == 1, 1, 0)
  return(check_label)
}

get_check_values(c("Erststimme", "ungültig", "nicht"), get_matches_vector(keywords = sequences, column = completions_df$gpt3))
```

## Function create_match_completions_df

```{r}
#' create_match_completions_df
#'
#' This function creates a data frame with match completions based on given keywords and check keywords.
#'
#' @param df A data frame containing the original data.
#' @param keywords A character vector of keywords to search for.
#' @param check_keywords A character vector of keywords to mark words that trigger manual review.
#' @param ... Additional arguments passed to the underlying functions.
#'
#' @return A data frame with columns for ID, completion, matched values, and check manually values.
#'
#' @examples
#' keywords <- c("keyword1", "keyword2", "keyword3")
#' check_keywords <- c("Erststimme", "ungültig", "nicht")
#' completions_df <- data.frame(id = c(1, 2, 3), gpt3 = c("This is keyword1", "No match here", "Another keyword2 match"))
#' create_match_completions_df(completions_df, keywords, check_keywords)
#'

create_match_completions_df <- function (df, keywords, check_keywords, ...) {
  assert_data_frame(df, col.names = "named", types = c("numeric", "character", "character", "numeric") , ncols = 4)
  assert_character(keywords, min.len = 1)
  assert_character(check_keywords)
  
  matches <- get_matches_vector(keywords = sequences, column = df[["gpt3"]])
  check_manual <- get_check_values(check_keywords, matches)
  df <- data.frame(
    id = df[["id"]],
    completion = df[["gpt3"]],
    matched = matches,
    check_manually = check_manual
  )
  return(df)
}

match_completions <-  create_match_completions_df(completions_df, keywords = sequences, check_keywords = c("Erststimme", "ungültig", "nicht"))
```


## Create mc_GLES2017

```{r}
# Joins matching and GLES datasets by ID to compare match with vote
mc_GLES2017 <- left_join(match_completions, GLES2017, by = c("id" = "lfdn"))
```

!!! MANUAL CHECKS NEED TO HAPPEN AT THIS STEP !!!

```{r}
# Export for manual checks
write.csv(mc_GLES2017, file = "GPT4PO_manualchecks.csv", col.names = T, row.names = F)
```

!!! RE-SAMPLING NAs NEEDS TO HAPPEN AT THIS STEP !!!

--> Run script "GPT4PO_Resampling.Rmd", then return back here

```{r}
mc_GLES2017 <- read.csv("GPT4PO_manual_checked.csv") # read in manually checked data
# mc_resample should be in environment from resampling script, otherwise saved as mc_resample.Rdata

mc_GLES2017_final <- bind_rows(mc_GLES2017, mc_resample) # merge datasets

sum(is.na(mc_GLES2017_final$sample_no)) # check whether we have sample_no for each row

mc_GLES2017_final <- mc_GLES2017_final %>% mutate(id_sampleno = paste(id, sample_no, sep = "_")) # create unique identifier per sample for each ID
```


# Match 2: Party Keywords - GLES Vote

Create a function that
- checks whether any of the strings in match_completions$matched match with GLES2017$vote (match rows via "id") and records this as 1 if matching, 0 otherwise.
- again, case insensitive and counting partial strings
- see below for what is considered a match (GLES2017$vote | match_completions$matched):

CDU/CSU | "CDU" OR "CSU" OR "CDU/CSU" OR "Union" OR "christ"
SPD | "SPD" OR "sozialdemokrat"
Bündnis 90/Die Grünen | "Grüne" OR "B90" OR "Bündnis" (besser "grün"?)
FDP | "FDP" OR "freie" OR "liberal"
Die Linke | "Linke" OR "links" (besser "link"?)
AfD | "AfD" OR "Alternative"

NEW
Andere Partei | "Andere"
Ungültig gewählt | "ungültig"
Nicht gewählt | "nicht"

## Help functions check_match
```{r}
#' check_match_party (helper)
#'
#' This function checks for matches between the vote and matched_new column of the joined dataframe mc_GLES2017_final
#'
#' @param mc_GLES2017_final The left-joined (by id and lfdn) dataframes of (matches_completions and GLES2017) and (matches_completions_resample and resample)
#'
#' @return A logical list indicating if vote and matched column match
#'
#' @examples
#' df <- data.frame(matched = c("This is CDU/CSU", "No match here", "Another SPD match"), vote = c("CDU/CSU", "FDP", "SPD"))
#' check_match_cdu_csu(df)
#' check_match_fdp(df)
#' check_match_spd(df)

# CDU/CSU 
check_match_cdu_csu <- function (mc_GLES2017_final) {
  pattern_cdu_csu <- paste0(".*", paste(c("CDU/CSU","CDU", "CSU", "Union", "christ"), collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_cdu_csu, ignore.case = TRUE)
}
# SPD
check_match_spd <- function (mc_GLES2017_final) {
  pattern_spd <- paste0(".*", paste(c("SPD", "sozialdemokrat"), collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_spd, ignore.case = TRUE)
}
# Grüne
check_match_gruene <- function (mc_GLES2017_final) {
  pattern_gruene <- paste0(".*", paste(c("Grüne", "B90", "Bündnis"), collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_gruene, ignore.case = TRUE)
}
# FDP 
check_match_fdp <- function (mc_GLES2017_final) {
  pattern_fdp <- paste0(".*", paste(c("FDP","freie", "liberal"), collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_fdp, ignore.case = TRUE)
}
# Die Linke
check_match_linke <- function (mc_GLES2017_final) {
  pattern_linke <- paste0(".*", paste(c("Linke","links"), collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_linke, ignore.case = TRUE)
}
# AFD
check_match_afd <- function (mc_GLES2017_final) {
  pattern_afd <- paste0(".*", paste(c("AfD","Alternative"), collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_afd, ignore.case = TRUE)
}

# Leah: add matches for "nicht", "ungültig" and "Andere" (Andere: might need to update matching script above too?)

# Andere Partei
check_match_andere <- function (mc_GLES2017_final) {
  pattern_andere <- paste0(".*", paste("Andere", collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_andere, ignore.case = TRUE)
}

# Ungültig gewählt
check_match_ung <- function (mc_GLES2017_final) {
  pattern_ung <- paste0(".*", paste("ungültig", collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_ung, ignore.case = TRUE)
}

# Nicht gewählt
check_match_nicht <- function (mc_GLES2017_final) {
  pattern_nicht <- paste0(".*", paste("ungültig", collapse = "|"), ".*")
  lapply(mc_GLES2017_final$matched_new, grepl, pattern = pattern_nicht, ignore.case = TRUE)
}

```

## Create match_voted outcome
```{r}
match_vote_outcome <-  case_when(
    mc_GLES2017_final$vote %in% "CDU/CSU" ~ check_match_cdu_csu(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "SPD" ~ check_match_spd(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "Bündnis 90/Die Grünen" ~ check_match_gruene(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "FDP" ~ check_match_fdp(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "Die Linke" ~ check_match_linke(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "AfD" ~ check_match_afd(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "Andere Partei" ~ check_match_andere(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "Ungültig gewählt" ~ check_match_ung(mc_GLES2017_final),
    mc_GLES2017_final$vote %in% "Nicht gewählt" ~ check_match_nicht(mc_GLES2017_final)
)
match_vote_outcome[which(unlist(lapply(match_vote_outcome, is.null)))] <- NA

mc_GLES2017_final <- mc_GLES2017_final %>% 
  mutate(match_vote_outcome = match_vote_outcome)

```

# Save final dataset!
```{r}
save(mc_GLES2017_final, file = "GPT4PO_data_complete_2017.Rdata") # save final dataset
```

