---
title: "GPT matching function"
author: "Leah von der Heyde, Max Lang"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(stringr)
library(dplyr)
library(checkmate)
```

Load test data

```{r}
load("test_completions.RData")
```

```{r}
# Adding more tests to completions_df
completions_df <- rbind(completions_df, data.frame(n = 1, prompt= NA, id = 3, gpt3= "Ich bin sozialdemokratischer Gesinnung. Ich wähle aber Grüne. Meine Religion ist christlich geprägt."))
completions_df <- rbind(completions_df, data.frame(n = 1, prompt= NA, id = 3, gpt3= "Ich  spiele Basketball"))
completions_df <- rbind(completions_df, data.frame(n = 1, prompt= NA, id = 3, gpt3= "Mein Freund wählt nicht CDU/CSU."))
completions_df <- rbind(completions_df, data.frame(n = 1, prompt= NA, id = 3, gpt3= "Er wählt nur B90."))
```

```{r}
sequences <- c("SPD", "CDU/CSU","CDU", "CSU", "Union", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christlich", "frei", "liberal", "Alternative", "nicht", "ungültig", "Erststimme")
check_sequences <- c("nicht", "ungültig", "Erststimme")
```


# Function get_matches_vector

```{r}
#' get_matches_vector
#'
#' This function extracts matches from a column based on a set of keywords.
#'
#' @param keywords A character vector of keywords to search for.
#' @param column A character vector representing the column to search in.
#' @param delimiter A character string to use as a delimiter when collapsing the matches. Default is a space (" ").
#' @param replace_zero_length Logical indicating whether to replace zero-length matches (character(0L)) with NA. Default is TRUE.
#'
#' @return A character vector containing the matches found, collapsed using the specified delimiter.
#'
#' @examples
#' keywords <- c("keyword1", "keyword2", "keyword3")
#' completions_df <- data.frame(gpt3 = c("This is keyword1", "No match here", "Another keyword2 match"))
#' get_matches_vector(keywords, completions_df$gpt3)
#'


get_matches_vector <- function(keywords, column, delimiter = " ", replace_zero_length = TRUE) {
  assert_character(keywords, min.len = 1)
  assert_character(column)
  assert_character(delimiter, any.missing = FALSE, len = 1,)
  assert_logical(replace_zero_length, any.missing = FALSE, len = 1)
  
  keywords <- gsub("([.\\[\\{\\(\\*\\+\\?\\^\\$\\|\\\\])", "\\\\\\1", keywords, perl = TRUE)
  pattern <- paste0(".*", paste(keywords, collapse = "|"), ".*")
  matches <- str_extract_all(column, regex(pattern, ignore_case = TRUE))
  if (replace_zero_length) {
    matches <- lapply(matches, function(x) if(identical(x, character(0))) NA_character_ else x)
  }
  matches <- sapply(matches, paste, collapse = delimiter)
  return(matches)
}

get_matches_vector(keywords = sequences, column = completions_df$gpt3)

# Leah: Extracts only matching keywords for some rows, almost entire gpt3 sequence for row 2? Why? Should be "Erststimme SPD Bündnis Grüne" 
  
```

# Function get_check_value

```{r}
#' get_check_values
#'
#' This function checks if specific keywords are present in a set of matches.
#'
#' @param check_keywords A character vector of keywords to label for manual revision.
#' @param matches_split A character vector returned from the fucntion `get_matches_vector`
#' @param split_by A character string to use as a delimiter when splitting the matches. Default is a space (" ").
#'
#' @return A numeric vector indicating whether each keyword is present in each match. 1 indicates presence, 0 indicates absence.
#'
#' @examples
#' check_keywords <- c("Erststimme", "unggültig", "nicht")
#' matches <- get_matches_vector(keywords = sequences, column = completions_df$gpt3)
#' get_check_values(check_keywords, matches)
#'


get_check_values <- function(check_keywords, matches, split_by = " ") {
  assert_character(check_keywords, min.len = 1)
  assert_character(matches)
  assert_character(split_by, any.missing = FALSE, len = 1)

  check_manual_pattern <- paste0("\\b(", paste0(check_keywords, collapse = "|"), ")\\b")
  check_manual <- unlist(lapply(str_split(matches, split_by), function (x) {as.numeric(any(x %in% check_keywords))}))
  return(check_manual)
}

get_check_values(c("Erststimme", "unggültig", "nicht"), get_matches_vector(keywords = sequences, column = completions_df$gpt3))


# Leah: Need to also flag cases where multiple parties are mentioned when there is no "Erststimme" / "nicht" / "ungültig" present! E.g. row 4
```

# Function create_match_completions_df

```{r}
#' create_match_completions_df
#'
#' This function creates a data frame with match completions based on given keywords and check keywords.
#'
#' @param df A data frame containing the original data.
#' @param keywords A character vector of keywords to search for.
#' @param check_keywords A character vector of keywords to mark words that trigger manual review.
#' @param ... Additional arguments passed to the underlying functions.
#'
#' @return A data frame with columns for ID, completion, matched values, and check manually values.
#'
#' @examples
#' keywords <- c("keyword1", "keyword2", "keyword3")
#' check_keywords <- c("Erststimme", "ungültig", "nicht")
#' completions_df <- data.frame(id = c(1, 2, 3), gpt3 = c("This is keyword1", "No match here", "Another keyword2 match"))
#' create_match_completions_df(completions_df, keywords, check_keywords)
#'

create_match_completions_df <- function (df, keywords, check_keywords, ...) {
  assert_data_frame(df, col.names = "named", types = c("numeric", "character", "character", "numeric") , ncols = 4)
  assert_character(keywords, min.len = 1)
  assert_character(check_keywords)
  
  matches <- get_matches_vector(keywords = sequences, column = df[["gpt3"]])
  check_manual <- get_check_values(check_keywords, matches)
  df <- data.frame(
    id = df[["id"]],
    completion = df[["gpt3"]],
    matched = matches,
    check_manually = check_manual
  )
  return(df)
}


match_completions <-  create_match_completions_df(completions_df, keywords = sequences, check_keywords = c("Erststimme", "unggültig", "nicht"))
```

Leah: Note to self: need to think about when/how to check & manipulate manual checks: before joining or before checking match?

# Create mc_GLES2017
```{r}

# Joins matching and GLES datasets by ID to compare match with vote

mc_GLES2017 <- left_join(match_completions, GLES2017, by = c("id" = "lfdn"))
```


# check_match help functions
```{r}
#' check_match_party (helper)
#'
#' This function checks for matches between the vote and matched column of the joined dataframe mc_GLES2017
#'
#' @param mc_GLES2017 The left-joined (by id and lfdn) dataframe of matches_completions and GLES2017
#'
#' @return A logical list indicating if vote and matched column match
#'
#' @examples
#' df <- data.frame(matched = c("This is CDU/CSU", "No match here", "Another SPD match"), vote = c("CDU/CSU", "FDP", "SPD"))
#' check_match_cdu_csu(df)
#' check_match_fdp(df)
#' check_match_spd(df)

# CDU/CSU 
check_match_cdu_csu <- function (mc_GLES2017) {
  pattern_cdu_csu <- paste0(".*", paste(c("CDU/CSU","CDU", "CSU", "Union"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_cdu_csu, ignore.case = TRUE)
}
# SPD
check_match_spd <- function (mc_GLES2017) {
  pattern_spd <- paste0(".*", paste(c("SPD", "sozialdemokrat"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_spd, ignore.case = TRUE)
}
# Grüne
check_match_gruene <- function (mc_GLES2017) {
  pattern_gruene <- paste0(".*", paste(c("Grüne", "B90", "Bündnis"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_gruene, ignore.case = TRUE)
}
# FDP 
check_match_fdp <- function (mc_GLES2017) {
  pattern_fdp <- paste0(".*", paste(c("FDP","freie", "liberal"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_fdp, ignore.case = TRUE)
}
# Die Linke
check_match_linke <- function (mc_GLES2017) {
  pattern_linke <- paste0(".*", paste(c("Linke","links"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_linke, ignore.case = TRUE)
}
# AFD
check_match_afd <- function (mc_GLES2017) {
  pattern_afd <- paste0(".*", paste(c("AfD","Alternative"), collapse = "|"), ".*")
  lapply(mc_GLES2017$matched, grepl, pattern = pattern_afd, ignore.case = TRUE)
}
```


# Create match_voted outcome
```{r}
match_vote_outcome <-  case_when(
    mc_GLES2017$vote %in% "CDU/CSU" ~ check_match_cdu_csu(mc_GLES2017),
    mc_GLES2017$vote %in% "SPD" ~ check_match_spd(mc_GLES2017),
    mc_GLES2017$vote %in% "Bündnis 90/Die Grünen" ~ check_match_gruene(mc_GLES2017),
    mc_GLES2017$vote %in% "FDP" ~ check_match_fdp(mc_GLES2017),
    mc_GLES2017$vote %in% "Die Linke" ~ check_match_linke(mc_GLES2017),
    mc_GLES2017$vote %in% "AfD" ~ check_match_afd(mc_GLES2017)
)

# Leah: Can the boolean column be appended to the mc_ dataset as match_vote ?

```


-------- OLD ----------

# Draft code 

```{r}

# Specify the character sequences to search for
sequences <- c("SPD", "CDU", "CSU", "Union", "CDU/CSU", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christlich", "frei", "liberal", "Alternative", "nicht", "ungültig", "Erststimme")

# Create an empty data frame to store the extracted data
match_completions_df <- data.frame(
  completion = character(),
  matched = character(),
  check_manually = integer()
)

# Iterate over rows in the completions_df$gpt3 column
for (row in completions_df$gpt3) {
  # Initialize an empty vector to store the matched sequences
  matched_sequences <- character()

  # Iterate over the specified character sequences
  for (sequence in sequences) {
    # Check if the row contains the current sequence
    if (grepl(sequence, row, ignore.case = TRUE, fixed = TRUE)) {
      # Append the matched sequence to the vector
      matched_sequences <- c(matched_sequences, sequence)
    }
  }

  # Check if any matches were found
  if (length(matched_sequences) > 0) {
    # NOT WORKING YET: Check if the row contains "Erststimme", "nicht", or "ungültig" - doesn't work for "nicht" / "ungültig"
    check_manually <- ifelse(grepl("Erststimme", row, ignore.case = TRUE, fixed = TRUE) | grepl("nicht", row, ignore.case = TRUE, fixed = TRUE) | grepl("ungültig", row, ignore.case = TRUE, fixed = TRUE), 1, 0)

    # ADD ID VARIABLE: Append the extracted data to the match_completions_df
    match_completions_df <- rbind(match_completions_df, data.frame(completion = row, matched = paste(matched_sequences, collapse = ", "), check_manually = check_manually))
  }
}

# Remove the empty first row from the match_completions_df
match_completions_df <- match_completions_df[-1, ]

```

1. Create a function that
- checks whether completions_df$gpt3 contains any of the following strings:
c("SPD", "CDU", "CSU", "Union", "CDU/CSU", "FDP", "AfD", "Linke", "Grüne", "Bündnis", "B90", "sozialdemokrat", "christlich", "frei", "liberal", "links", Alternative", "nicht", "ungültig", "Erststimme")
(case-insensitive, also partial strings, e.g. "sozialdemokratisch" und "sozialdemokraten"
should both be recognized by " * sozialdemokrat * ") - DONE

- stores all the matched strings per row in a new df and column: match_completions_df$matched; if there is no match, the column should remain empty but still store the respective row
- marks those rows that contain "Erststimme", "nicht" OR "ungültig" by creating a column "check_manually" that takes the value 1 if any of these conditions are met
- also stores the following columns from the completions_df: "id" as "id" and "gpt3" as "completion"

2. Create a function that
- checks whether any of the strings in match_completions$matched match with GLES2017$vote (match rows via "id") and records this as 1 if matching, 0 otherwise.
- again, case insensitive and counting partial strings
- see below for what is considered a match (GLES2017$vote | match_completions$matched):

CDU/CSU | "CDU" OR "CSU" OR "CDU/CSU" OR Union
SPD | "SPD" OR "sozialdemokrat"
Bündnis 90/Die Grünen | "Grüne" OR "B90" OR "Bündnis"
FDP | "FDP" OR "freie" OR "liberal"
Die Linke | "Linke" OR "Links"
AfD | "AfD" OR "Alternative"

for GLES "andere Partei", "ungültig gewählt", "nicht gewählt": we need to double-check and determine accordingly; can be tackled at a later point
