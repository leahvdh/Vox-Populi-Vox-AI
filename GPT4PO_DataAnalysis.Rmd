---
title: 'GPT for Public Opinion: Data Analysis'
author: "Leah von der Heyde, Alexander Wenz, Carolina Haensch"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggmosaic)
library(nnet)
library(ggstats)
library(coefplot)
library(stargazer)
library(vtable)
library()
options(scipen = 999)

#load("GPT4PO_data_complete_2017.Rdata")
```

# Data Transformation

For regression analyses:
- Excluded 78 NAs from models for comparability
- Treated variables with min. 5 categories as numeric
- partyid_degree*partyid, as strength and direction of partisanship logically interact

```{r}
data_final_factors <- mc_GLES2017_final %>%
                      mutate(
    female = factor(female,
                    levels = c("männlich","weiblich"),
                    labels = c("männlich","weiblich")),
    edu = factor(edu,
                 levels = c("keinen Schulabschluss",
                            "einen Hauptschulabschluss",
                            "einen Realschulabschluss",
                            "Abitur",
                            "einen Hochschulabschluss"), 
                 labels = c("keinen Schulabschluss",
                            "einen Hauptschulabschluss",
                            "einen Realschulabschluss",
                            "Abitur",
                            "einen Hochschulabschluss"),
                 ordered = FALSE),
    emp = factor(emp,
                 levels = c("berufstätig",
                            "nicht berufstätig",
                            "in Ausbildung"),
                 labels = c("berufstätig",
                            "nicht berufstätig",
                            "in Ausbildung")),
    hhincome = factor(hhincome,
                      levels = c("niedriges", "mittleres", "hohes"), 
                      labels = c("niedriges", "mittleres", "hohes"),
                      ordered = FALSE),
    east = factor(east,
                  levels = c("Westdeutschland",
                             "Ostdeutschland"),
                  labels = c("Westdeutschland",
                             "Ostdeutschland")),
    religious = factor(religious,
                       levels = c("überhaupt nicht religiös",
                                  "nicht sehr religiös",
                                  "etwas religiös",
                                  "sehr religiös"), 
                       labels = c("überhaupt nicht religiös",
                                  "nicht sehr religiös",
                                  "etwas religiös",
                                  "sehr religiös"),
                       ordered = FALSE),
    leftright = factor(leftright,
                       levels = c("stark links",
                                  "mittig links",
                                  "in der Mitte",
                                  "mittig rechts",
                                  "stark rechts"),
                       labels = c("stark links",
                                  "mittig links",
                                  "in der Mitte",
                                  "mittig rechts",
                                  "stark rechts"),
                       ordered = FALSE),
    partyid = factor(partyid,
                     levels = c("mit der Partei CDU/CSU",
                                "mit der Partei SPD", 
                                "mit der Partei FDP",
                                "mit der Partei Bündnis 90/Die Grünen",
                                "mit der Partei Die Linke",
                                "mit der Partei AfD",
                                "mit einer Kleinpartei",
                                "mit keiner Partei"),
                     labels = c("CDU/CSU",
                                "SPD", 
                                "FDP",
                                "Die Grünen",
                                "Die Linke",
                                "AfD",
                                "Kleinpartei",
                                "keine Partei")),
    partyid_degree = ifelse(partyid_degree == "", "überhaupt nicht", partyid_degree), # NAs to zero
    partyid_degree = factor(partyid_degree,
                            levels = c("überhaupt nicht",
                                       "sehr schwach ",
                                       "ziemlich schwach ",
                                       "mäßig ",
                                       "ziemlich stark ",
                                       "sehr stark "),
                            labels = c("überhaupt nicht",
                                       "sehr schwach",
                                       "ziemlich schwach",
                                       "mäßig",
                                       "ziemlich stark",
                                       "sehr stark"),
                            ordered = FALSE),
    inequality = factor(inequality,
                        levels = c("Maßnahmen ergreifen",
                                   "habe keine Meinung dazu, ob die Regierung Maßnahmen ergreifen sollte",
                                   "keine Maßnahmen ergreifen"),
                        labels = c("Maßnahmen ergreifen",
                                   "habe keine Meinung dazu",
                                   "keine Maßnahmen ergreifen"),
                        ordered = FALSE),
    immigration = factor(immigration,
                         levels = c("erleichtern",
                                    "weder erleichtern noch einschränken",
                                    "einschränken"), 
                         labels = c("erleichtern",
                                    "weder erleichtern noch einschränken",
                                    "einschränken"),
                         ordered = FALSE),
    vote = factor(vote,
                  levels = c("CDU/CSU",
                             "SPD",
                             "Bündnis 90/Die Grünen",
                             "FDP",
                             "Die Linke",
                             "AfD",
                             "Andere Partei",
                             "Ungültig gewählt",
                             "Nicht gewählt"),
                  labels = c("CDU/CSU",
                             "SPD",
                             "Bündnis 90/Die Grünen",
                             "FDP",
                             "Die Linke",
                             "AfD",
                             "Andere Partei",
                             "Ungültig gewählt",
                             "Nicht gewählt")),
    vote_gpt = factor(vote_gpt,
                      levels = c("CDU/CSU",
                             "SPD",
                             "Bündnis 90/Die Grünen",
                             "FDP",
                             "Die Linke",
                             "AfD",
                             "Andere Partei",
                             "Ungültig gewählt",
                             "Nicht gewählt"),
                      labels = c("CDU/CSU",
                             "SPD",
                             "Bündnis 90/Die Grünen",
                             "FDP",
                             "Die Linke",
                             "AfD",
                             "Andere Partei",
                             "Ungültig gewählt",
                             "Nicht gewählt"))
                      )
# Transform variables with 5 categories to numeric
# maybe even hhincome, religious; inequality, immigration?
data_final_numeric <- data_final_factors %>%
                      mutate(
                        edu = ifelse(edu == "keinen Schulabschluss", 0,
                                     ifelse(edu == "einen Hauptschulabschluss", 1,
                                            ifelse(edu == "einen Realschulabschluss", 2,
                                                   ifelse(edu == "Abitur", 3,
                                                          ifelse(edu == "einen Hochschulabschluss", 4,
                                                                 NA))))),
                        leftright = ifelse(leftright == "stark links", -2,
                                           ifelse(leftright == "mittig links", -1,
                                                  ifelse(leftright == "in der Mitte", 0,
                                                         ifelse(leftright == "mittig rechts", 1,
                                                                ifelse(leftright == "stark rechts", 2,
                                                                       NA))))),
                        partyid_degree = ifelse(partyid_degree == "überhaupt nicht", 0,
                                                ifelse(partyid_degree == "sehr schwach", 1,
                                                       ifelse(partyid_degree == "ziemlich schwach", 2,
                                                              ifelse(partyid_degree == "mäßig", 3,
                                                                     ifelse(partyid_degree == "ziemlich stark", 4,
                                                                            ifelse(partyid_degree == "sehr stark", 5,
                                                                                   NA))))))
                      )

# Removing respondents that have at least one NA in gpt_vote (for comparability between samples)

data_final_numeric_noNA <- data_final_numeric %>%
                           drop_na("vote_gpt") %>% 
                           group_by(id) %>%
                           filter(sum(id)/5==id) %>%
                           ungroup()
```

# MATCHING: Prediction between GPT and GLES

Can LLMs accurately emulate response distributions of population subgroups?

## Aggregate: Shares of correct and incorrect matches overall

### Tables

```{r}
# Overall
table_matches_overall_c <- table(mc_GLES2017_final$match_vote_outcome)
table_matches_overall_s <- prop.table(table_matches_overall_c)

data_matches_overall_s <- as.data.frame(table_matches_overall_s)
data_matches_overall_s <- data_matches_overall_s %>%
                          mutate(sample = "Overall") %>%
                          rename(match = Var1)

# Per sample
table_matches_counts <- table(mc_GLES2017_final$match_vote_outcome, mc_GLES2017_final$sample_no)
table_matches_shares <- prop.table(table_matches_counts, 2)

data_matches_shares <- as.data.frame(table_matches_shares)
data_matches_shares <- data_matches_shares %>%
                       rename(sample = Var2) %>%
                       rename(match = Var1)
# Together
data_matches_shares_all <- bind_rows(data_matches_overall_s, data_matches_shares)
data_matches_shares_all <- data_matches_shares_all %>%
                           mutate(sample = factor(sample, 
                                  levels = c("Overall", "1", "2", "3", "4", "5"),
                                  labels = c("Overall", "1", "2", "3", "4", "5")))
```

### Plot

```{r}
plot_matches <- ggplot(data_matches_shares_all,
                       aes(x = sample,
                           y = Freq,
                           fill = match)) +
                      geom_bar(stat = "identity", position = "stack") +
                      geom_text(aes(label = paste0(round(Freq*100,1),"%")), 
                                position = position_fill(0.5), color = c(rep(c("white", "black"), 6))) +
                      xlab("Sample") +
                      ylab("") +
                      scale_fill_manual(values = c("FALSE" = "#faa32b", "TRUE" = "#1e31fa"), 
                                        labels = c("different", "match"),
                                        name = "GPT Prediction") +
                      scale_y_continuous(labels = scales::percent) +
                      ggtitle("") +
                      theme_minimal()

ggsave("matches.png", plot_matches, height = 6, width = 8)
```

```{r}
plot_matches
```

### Variance Estimation

```{r}
# Calculate proportions and its variance for each iteration
sample_proportions_match <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

# Calculate the between-iteration variance and total variance
mean_proportions_match <- sample_proportions_match %>%
    group_by(match_vote_outcome) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    arrange(desc(mean_prop))
```

- There is very little variance across samples
- In 54% of cases, the GPT prediction does not match the person's GLES vote
- No need to plot variance estimation as there is so little variance (see above)

## Aggregate: Recall - Shares of correct and incorrect matches by GLES party vote

### Tables

```{r}
# Across samples
table_matches_parties_s <- prop.table(table(mc_GLES2017_final$vote, mc_GLES2017_final$match_vote_outcome), 1)

# Sample 1
table_matches_parties_s_1 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 1], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 1]), 1)

# Sample 2
table_matches_parties_s_2 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 2], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 2]), 1)

# Sample 3
table_matches_parties_s_3 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 3], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 3]), 1)

# Sample 4
table_matches_parties_s_4 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 4], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 4]), 1)

# Sample 5
table_matches_parties_s_5 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 5], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 5]), 1)

```

### Plot

```{r}
data_matches_parties_s <- as.data.frame(table_matches_parties_s)
data_matches_parties_s <- data_matches_parties_s %>%
                            rename(match = Var2) %>%
                            rename(party = Var1)

data_matches_overall_parties_s <- data_matches_overall_s %>%
                                  rename(party = sample) %>%
                                  mutate(party = factor(party))


data_matches_parties_all <- bind_rows(data_matches_overall_parties_s, data_matches_parties_s) %>%
                            mutate(party = ifelse(party == "Bündnis 90/Die Grünen", "Greens",
                                         ifelse(party == "Die Linke", "Left",
                                         ifelse(party == "Andere Partei", "Small party",
                                         ifelse(party == "Ungültig gewählt", "Invalid vote",
                                         ifelse(party == "Nicht gewählt", "No vote",
                                         ifelse(party == "CDU/CSU", "CDU/CSU",
                                         ifelse(party == "FDP", "FDP",
                                         ifelse(party == "SPD", "SPD",
                                         ifelse(party == "AfD", "AfD", 
                                         ifelse(party == "Overall", "Overall", party)))))))))))

plot_matches_parties <- ggplot(data_matches_parties_all,
                       aes(x = party,
                           y = Freq,
                           fill = match)) +
                      geom_bar(stat = "identity", position = "stack") +
                      geom_text(aes(label = paste0(round(Freq*100,1),"%")),
                                # TO DO: fix colors white/black
                                position = position_fill(0.5), color = "white") +
                      xlab("Vote Choice (GLES)") +
                      ylab("") +
                      scale_x_discrete(limits = c("Overall", "Greens", "CDU/CSU", "Left",
                                                  "SPD", "FDP", "AfD", "Small party", "No vote",
                                                  "Invalid vote")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      scale_fill_manual(values = c("FALSE" = "#faa32b", "TRUE" = "#1e31fa"), 
                                        labels = c("different", "match"),
                                        name = "GPT Prediction") +
                      ggtitle("") +
                      theme_minimal() +
                      theme(panel.grid.minor = element_blank(),
                            panel.grid.major = element_blank())

ggsave("matches_parties.png", plot_matches_parties, height = 4, width = 8)

```

```{r}
plot_matches_parties
```

- GPT and GLES match less for voters of parties that received fewer votes according to GLES! (Except Left)
--> It's easier for GPT to predict popular / people's parties as it is more clear who will vote for them, historically (training data / evidence)?

#### TO DO: Mosaic Plot (by GLES party vote share)

```{r}

# TO DO: change fill colors & legend labels, sort parties by size, replace y-axis with % share, change x- & y-axis labels
plot_matches_parties_mosaic <- ggplot(mc_GLES2017_final) +
                              geom_mosaic(aes(x = product(vote), fill=match_vote_outcome)) +
                              theme_mosaic() +
                              xlab("Party") +
                              ylab("") #+
#                             scale_x_discrete(limits = c("CDU/CSU", "SPD", "Bündnis 90/Die Grünen",
#                                                          "FDP", "Die Linke", "AfD",
#                                                          "Andere Partei", "Nicht gewählt",
#                                                          "Ungültig gewählt")) + # reorder
#                             scale_fill_manual(values = c("FALSE" = "#8F2809", "TRUE" = "#74aa9c"),
#                                        labels = c("different", "match"),
#                                        name = "GPT Prediction")

```

## Aggregate: Precision: Share of correct and incorrect matches by GPT party vote

### Tables

```{r}
# Sample 1
table_matches_gpt_s_1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 1], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 1]), 1)

# Sample 2
table_matches_gpt_s_2 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 2], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 2]), 1)

# Sample 3
table_matches_gpt_s_3 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 3], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 3]), 1)

# Sample 4
table_matches_gpt_s_4 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 4], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 4]), 1)

# Sample 5
table_matches_gpt_s_5 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 5], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 5]), 1)
```

### Plot

#### TO DO: Alternate label colors (white/black)

```{r}
data_matches_gpt_s <- as.data.frame(table_matches_gpt_s)
data_matches_gpt_s <- data_matches_gpt_s %>%
                            rename(match = Var2) %>%
                            rename(party = Var1)

data_matches_gpt_all <- bind_rows(data_matches_overall_parties_s, data_matches_gpt_s) %>%
                            mutate(party = ifelse(party == "Bündnis 90/Die Grünen", "Greens",
                                         ifelse(party == "Die Linke", "Left",
                                         ifelse(party == "Andere Partei", "Small party",
                                         ifelse(party == "Ungültig gewählt", "Invalid vote",
                                         ifelse(party == "Nicht gewählt", "No vote",
                                         ifelse(party == "CDU/CSU", "CDU/CSU",
                                         ifelse(party == "FDP", "FDP",
                                         ifelse(party == "SPD", "SPD",
                                         ifelse(party == "AfD", "AfD", 
                                         ifelse(party == "Overall", "Overall", party)))))))))))

plot_matches_gpt <- ggplot(data_matches_gpt_all,
                       aes(x = party,
                           y = Freq,
                           fill = match)) +
                      geom_bar(stat = "identity", position = "stack") +
                      geom_text(aes(label = paste0(round(Freq*100,1),"%")),
                                # TO DO: fix colors white/black
                                position = position_fill(0.5), color = "white") +
                      xlab("Vote Choice (GPT)") +
                      ylab("") +
                      scale_x_discrete(limits = c("Overall", "CDU/CSU", "Small party", "SPD",
                                                  "Greens", "AfD", "FDP", "Left",
                                                  "No vote", "Invalid vote")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      scale_fill_manual(values = c("FALSE" = "#faa32b", "TRUE" = "#1e31fa"), 
                                        labels = c("different", "match"),
                                        name = "GPT Prediction") +
                      ggtitle("") +
                      theme_minimal() +
                      theme(panel.grid.minor = element_blank(),
                            panel.grid.major = element_blank())

ggsave("matches_gpt.png", plot_matches_gpt, height = 4, width = 8)
```

```{r}
plot_matches_gpt
```

## F1 Scores per party across samples

Precision refers to the number of correct predictions for a given party (true positives) divided by the number of all predicted votes for that party (positives), measuring the share of predicted vote choices for a given party that were correct. --> matches_gpt

Recall refers to the number of correct predictions for a given party (true positives) divided by the number of actual votes for that party, measuring the share of votes for a party that were correctly identified. --> matches_parties

F1 = 2 * precision * recall / precision + recall

```{r}
data_precision <- data_matches_gpt_all %>%
                  filter(match == TRUE) %>%
                  rename(precision = Freq) %>%
                  select(precision, party)

data_recall <- data_matches_parties_all %>%
               filter(match == TRUE) %>%
               rename(recall = Freq) %>%
               select(recall, party)

data_f1 <- merge(data_precision, data_recall, by = "party")

data_f1 <- data_f1 %>%
           mutate(f1 = (2*precision*recall) / (precision + recall))

```

## Variance Estimation

### Recall

```{r}
# Calculate proportions and its variance for each iteration
sample_proportions_match_party <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

# Calculate the between-iteration variance and total variance
mean_proportions_match_party <- sample_proportions_match_party %>%
    group_by(match_vote_outcome, vote) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    arrange(desc(mean_prop))

data_recall_varest <- mean_proportions_match_party %>%
                         filter(match_vote_outcome == TRUE) %>%
                         select(vote, W, mean_prop, B, T_stderr) %>%
                         rename(recall = mean_prop,
                                recall_W = W,
                                recall_B = B,
                                recall_totalse = T_stderr,
                                party = vote)
```

### Precision

```{r}
# Calculate proportions and its variance for each iteration
sample_proportions_match_gpt <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote_gpt) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

# Calculate the between-iteration variance and total variance
mean_proportions_match_gpt <- sample_proportions_match_gpt %>%
    group_by(match_vote_outcome, vote_gpt) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    arrange(desc(mean_prop))

data_precision_varest <- mean_proportions_match_gpt %>%
                         filter(match_vote_outcome == TRUE) %>%
                         select(vote_gpt, W, mean_prop, B, T_stderr) %>%
                         rename(precision = mean_prop,
                                precision_W = W,
                                precision_B = B,
                                precision_totalse = T_stderr,
                                party = vote_gpt)
```

### F1

```{r}
data_f1_varest <- merge(data_precision_varest, data_recall_varest, by = "party")

data_f1_varest <- data_f1_varest %>%
                  mutate(f1 = (2*precision*recall) / (precision + recall)) %>%
                  select(!c(match_vote_outcome.x, match_vote_outcome.y))
```


## Individual level: Shares of correct and incorrect matches by persona (omit because not treating 5 samples as Var.Est.)

```{r}
table_matches_ids_s <- prop.table(table(mc_GLES2017_final$id, mc_GLES2017_final$match_vote_outcome), 1)

data_matches_ids_s <- as.data.frame(table_matches_ids_s)
data_matches_ids_s <- data_matches_ids_s %>%
                            rename(match = Var2) %>%
                            rename(id = Var1) %>%
                            pivot_wider(names_from = match,
                                        values_from = Freq,
                                        names_prefix = "match")

prop.table(table(data_matches_ids_s$matchTRUE))

plot_dist_matches <- hist(data_matches_ids_s$matchTRUE,
                                   breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),
                                   main = "Distribution of matching predictions per persona",
                                   xlab = "Share of matches in 5 samples",
                                   ylab = "Frequency")

ggsave("dist_matches.png", plot_dist_matches, height = 6, width = 8)

```

```{r}
plot_dist_matches
```

- In 34% of cases, GPT is consistently wrong; in 24% of cases, it's consistently correct
- In the remaining 42% of cases, it gets a majority of votes right 57% of the time (i.e. for over half of the cases/personas, 3 or 4 out of 5 predictions are correct).

## Individual level: Heatmap of % matches per subgroup

### Variance Estimation

Note:
- Aggregated age to 3 groups: 18-34, 35-64, 65+ (range in data: 18-95)
- There are no "Invalid vote" & Match == TRUE groups!

```{r}
# Gender

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_gender <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, female) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_gender <- sample_proportions_match_party_gender %>%
    group_by(match_vote_outcome, vote, female) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = female) %>%
    arrange(desc(mean_prop))

# Education

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_edu <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, edu) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_edu <- sample_proportions_match_party_edu %>%
    group_by(match_vote_outcome, vote, edu) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = edu) %>%
    arrange(desc(mean_prop))

# Employment Status

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_emp <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, emp) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_emp <- sample_proportions_match_party_emp %>%
    group_by(match_vote_outcome, vote, emp) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    rename(variable = emp) %>%
    arrange(desc(mean_prop))

# Income

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_inc <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, hhincome) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_inc <- sample_proportions_match_party_inc %>%
    group_by(match_vote_outcome, vote, hhincome) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = hhincome) %>%
    arrange(desc(mean_prop))

# East/West

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_east <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, east) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_east <- sample_proportions_match_party_east %>%
    group_by(match_vote_outcome, vote, east) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = east) %>%
    arrange(desc(mean_prop))

# Religiosity

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_relig <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, religious) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_relig <- sample_proportions_match_party_relig %>%
    group_by(match_vote_outcome, vote, religious) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = religious) %>%
    arrange(desc(mean_prop))

# LR-Ideology

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_leftright <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, leftright) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_leftright <- sample_proportions_match_party_leftright %>%
    group_by(match_vote_outcome, vote, leftright) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = leftright) %>%
    arrange(desc(mean_prop))

# Party ID

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_partyid <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, partyid) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_partyid <- sample_proportions_match_party_partyid %>%
    group_by(match_vote_outcome, vote, partyid) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = partyid) %>%
    arrange(desc(mean_prop))

# Strength of Party ID

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_piddegree <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, partyid_degree) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_piddegree <- sample_proportions_match_party_piddegree %>%
    group_by(match_vote_outcome, vote, partyid_degree) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = partyid_degree) %>%
    filter(variable != "") %>%
    arrange(desc(mean_prop))

# Att. Inequality

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_ineq <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, inequality) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_ineq <- sample_proportions_match_party_ineq %>%
    group_by(match_vote_outcome, vote, inequality) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    rename(variable = inequality) %>%
    arrange(desc(mean_prop))

# Att. Immigration

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_immig <- mc_GLES2017_final %>%
    group_by(sample_no, match_vote_outcome, vote, immigration) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_immig <- sample_proportions_match_party_immig %>%
    group_by(match_vote_outcome, vote, immigration) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = immigration) %>%
    arrange(desc(mean_prop))

# Age: Too many catgeories --> Aggregate to 3 groups

## Calculate proportions and its variance for each iteration
sample_proportions_match_party_age <- mc_GLES2017_final %>%
    mutate(age_grp = ifelse(age < 35, "18-34",
                            ifelse(age >=35 & age < 65, "35-64",
                                   ifelse(age >= 65, "65+", age)))) %>%
    group_by(sample_no, match_vote_outcome, vote, age_grp) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(match_vote_outcome) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

## Calculate the between-iteration variance and total variance
mean_proportions_match_party_age <- sample_proportions_match_party_age %>%
    group_by(match_vote_outcome, vote, age_grp) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules)
    rename(variable = age_grp) %>%
    arrange(desc(mean_prop))


mean_proportions_match_party_all <- bind_rows(mean_proportions_match_party_gender, mean_proportions_match_party_edu, mean_proportions_match_party_emp, mean_proportions_match_party_inc, mean_proportions_match_party_east, mean_proportions_match_party_relig, mean_proportions_match_party_leftright, mean_proportions_match_party_partyid, mean_proportions_match_party_piddegree, mean_proportions_match_party_ineq, mean_proportions_match_party_immig, mean_proportions_match_party_age)

```

### Plot

```{r}
data_heatmap_match <- mean_proportions_match_party_all %>%
                      select(match_vote_outcome, vote, variable, mean_prop) %>%
                      filter(match_vote_outcome == TRUE) %>%
                      mutate(vote = ifelse(vote == "Bündnis 90/Die Grünen", "Greens",
                                        ifelse(vote == "Die Linke", "Left",
                                        ifelse(vote == "Andere Partei", "Other party",
                                        ifelse(vote == "Ungültig gewählt", "Invalid vote",
                                        ifelse(vote == "Nicht gewählt", "No vote", vote)))))) %>%
                      mutate(variable = ifelse(variable == "18-34", "Age: 18-34",
                                        ifelse(variable == "35-64", "Age: 35-64",
                                        ifelse(variable == "65+", "Age: 65+",
                                        ifelse(variable == "weiblich", "Gender: female",
                                        ifelse(variable == "männlich", "Gender: male",
                                        ifelse(variable == "keinen Schulabschluss", "Education: no degree",
                                        ifelse(variable == "einen Hauptschulabschluss", "Education: Hauptschule",
                                        ifelse(variable == "einen Realschulabschluss", "Education: Realschule",
                                        ifelse(variable == "Abitur", "Education: Abitur",
                                        ifelse(variable == "einen Hochschulabschluss", "Education: College",
                                        ifelse(variable == "nicht berufstätig", "Employment: not working",
                                        ifelse(variable == "in Ausbildung", "Employment: studying",
                                        ifelse(variable == "berufstätig", "Employment: working",
                                        ifelse(variable == "niedriges", "Income: low",
                                        ifelse(variable == "mittleres", "Income: medium",
                                        ifelse(variable == "hohes", "Income: high",
                                        ifelse(variable == "Ostdeutschland", "Residence: East Germany",
                                        ifelse(variable == "Westdeutschland", "Residence: West Germany",
                                        ifelse(variable == "überhaupt nicht religiös", "Religiosity: not at all",
                                        ifelse(variable == "nicht sehr religiös", "Religiosity: not very",
                                        ifelse(variable == "etwas religiös", "Religiosity: somewhat",
                                        ifelse(variable == "sehr religiös", "Religiosity: very",
                                        ifelse(variable == "stark links", "Ideology: left",
                                        ifelse(variable == "mittig links", "Ideology: center-left",
                                        ifelse(variable == "in der Mitte", "Ideology: center",
                                        ifelse(variable == "mittig rechts", "Ideology: center-right",
                                        ifelse(variable == "stark rechts", "Ideology: right",
                                        ifelse(variable == "mit der Partei CDU/CSU", "Party ID: CDU/CSU",
                                        ifelse(variable == "mit der Partei SPD", "Party ID: SPD",
                                        ifelse(variable == "mit der Partei FDP", "Party ID: FDP",
                                        ifelse(variable == "mit der Partei Bündnis 90/Die Grünen", "Party ID: Greens",
                                        ifelse(variable == "mit der Partei Die Linke", "Party ID: Left",
                                        ifelse(variable == "mit der Partei AfD", "Party ID: AfD",
                                        ifelse(variable == "mit einer Kleinpartei", "Party ID: Small party",
                                        ifelse(variable == "mit keiner Partei", "Party ID: none",
                                        ifelse(variable == "sehr stark ", "Strength of PID: very strong",
                                        ifelse(variable == "ziemlich stark ", "Strength of PID: rather strong",
                                        ifelse(variable == "mäßig ", "Strength of PID: medium",
                                        ifelse(variable == "ziemlich schwach ", "Strength of PID: rather weak",
                                        ifelse(variable == "sehr schwach ", "Strength of PID: very weak",
                                        ifelse(variable == "Maßnahmen ergreifen", "Att. Inequality: take measures",
                                        ifelse(variable == "habe keine Meinung dazu, ob die Regierung Maßnahmen ergreifen sollte", "Att. Inequality: no opinion",
                                        ifelse(variable == "keine Maßnahmen ergreifen", "Att. Inequality: don't take measures",
                                               
                                        ifelse(variable == "erleichtern", "Att. Immigration: facilitate",
                                        ifelse(variable == "weder erleichtern noch einschränken", "Att. Immigration: neither nor",
                                        ifelse(variable == "einschränken", "Att. Immigration: limit", variable)))))))))))))))))))))))))))))))))))))))))))))))

plot_matches_subgroups <- ggplot(data_heatmap_match,
                          aes(x = vote,
                          y = variable,
                          fill = mean_prop)) +
  geom_tile() +
  xlab("Vote Choice (GLES)") +
  ylab("") +
  scale_x_discrete(limits = c("CDU/CSU", "SPD", "Greens", "FDP", "Left","AfD", "Other party", "No vote")) +
  scale_y_discrete(limits=c("Att. Immigration: facilitate", "Att. Immigration: neither nor", "Att. Immigration: limit","Att. Inequality: take measures",  "Att. Inequality: no opinion", "Att. Inequality: don't take measures",  "Strength of PID: very strong", "Strength of PID: rather strong", "Strength of PID: medium", "Strength of PID: rather weak", "Strength of PID: very weak",  "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "Party ID: CDU/CSU", "Ideology: right", "Ideology: center-right", "Ideology: center", "Ideology: center-left", "Ideology: left", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Religiosity: not at all", "Residence: West Germany", "Residence: East Germany", "Income: high", "Income: medium", "Income: low", "Employment: working", "Employment: studying", "Employment: not working", "Education: College", "Education: Abitur", "Education: Realschule", "Education: Hauptschule", "Education: no degree", "Gender: male","Gender: female", "Age: 65+", "Age: 35-64", "Age: 18-34")) + # reversed order bc plot converts it...
  scale_fill_gradient(low="white", high="#faa32b",
                      limits = c(0, 1),
                      name = "% Match Vote Choice GPT - GLES",
                      labels = scales::label_percent()) +
  theme_minimal() +
  theme(legend.position = "top",
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank(),
        panel.background = element_rect(fill = "grey", color = NA)
        )

ggsave("heatmap_matches_subgroups.png", plot_matches_subgroups, height = 9, width = 8)

```

```{r}
plot_matches_subgroups
```

- 7 combinations of subgroup/vote don't exist (blank/white in plot)
- Subgroups are singular per variable, i.e. not cross-cutting!
- Across subgroups, higher share of matches for voters of CDU/CSU, Greens, and Left (mirrors previous plot) --> generally fewer matches for FDP & AfD voters
- Within subgroups:
-- Higher share of matches for older CDU/CSU and SPD (maybe even Left) voters
-- Higher share of matches for female Left voters
-- Higher share of matches for higher-educated Green voters, and for lower-educated CDU/CSU, SPD, and non-voters; as well as for medium-educated left voters
-- Higher share of matches for non-working CDU/CSU voters
-- Higher share of matches for high-income Green, FDP, and Left voters, but also for low-income left voters
-- Higher share of matches for East German Left voters
-- Higher share of matches for religious CDU/CSU voters, non-religious Green and Left voters
-- Higher share of matches for ideologically left Left-voters (not so much Greens, those more for center-left), ideologically right FDP, SPD (!, weaker for CDU/CSU), and AfD voters
-- Higher share of matches for those who voted according to their party ID
-- Higher share of matches the stronger the party ID is - for AfD, higher share of matches for those with very weak party IDs!
-- Higher share of matches for inequality-concerned Green and Left voters, inequality unconcerned CDU/CSU voters
-- Higher share of matches for immigration-supporting Green voters (not Left!), immigration-limiting CDU/CSU voters

For poster: 

```{r}
data_heatmap_match_2 <- mean_proportions_match_party_all %>%
                      select(match_vote_outcome, vote, variable, mean_prop) %>%
                      filter(match_vote_outcome == TRUE) %>%
                      mutate(vote = ifelse(vote == "Bündnis 90/Die Grünen", "Greens",
                                        ifelse(vote == "Die Linke", "Left",
                                        ifelse(vote == "Andere Partei", "Other party",
                                        ifelse(vote == "Ungültig gewählt", "Invalid vote",
                                        ifelse(vote == "Nicht gewählt", "No vote", vote)))))) %>%
                      mutate(variable = ifelse(variable == "18-34", "18-34",
                                        ifelse(variable == "35-64", "35-64",
                                        ifelse(variable == "65+", "65+",
                                        ifelse(variable == "weiblich", "female",
                                        ifelse(variable == "männlich", "male",
                                        ifelse(variable == "keinen Schulabschluss", "no degree",
                                        ifelse(variable == "einen Hauptschulabschluss", "Hauptschule",
                                        ifelse(variable == "einen Realschulabschluss", "Realschule",
                                        ifelse(variable == "Abitur", "Abitur",
                                        ifelse(variable == "einen Hochschulabschluss", "College",
                                        ifelse(variable == "nicht berufstätig", "not working",
                                        ifelse(variable == "in Ausbildung", "studying",
                                        ifelse(variable == "berufstätig", "working",
                                        ifelse(variable == "niedriges", "low",
                                        ifelse(variable == "mittleres", "medium",
                                        ifelse(variable == "hohes", "high",
                                        ifelse(variable == "Ostdeutschland", "East Germany",
                                        ifelse(variable == "Westdeutschland", "West Germany",
                                        ifelse(variable == "überhaupt nicht religiös", "not at all",
                                        ifelse(variable == "nicht sehr religiös", "not very",
                                        ifelse(variable == "etwas religiös", "somewhat",
                                        ifelse(variable == "sehr religiös", "very",
                                        ifelse(variable == "stark links", "left",
                                        ifelse(variable == "mittig links", "center-left",
                                        ifelse(variable == "in der Mitte", "center",
                                        ifelse(variable == "mittig rechts", "center-right",
                                        ifelse(variable == "stark rechts", "right",
                                        ifelse(variable == "mit der Partei CDU/CSU", "CDU/CSU",
                                        ifelse(variable == "mit der Partei SPD", "SPD",
                                        ifelse(variable == "mit der Partei FDP", "FDP",
                                        ifelse(variable == "mit der Partei Bündnis 90/Die Grünen", "Greens",
                                        ifelse(variable == "mit der Partei Die Linke", "Left",
                                        ifelse(variable == "mit der Partei AfD", "AfD",
                                        ifelse(variable == "mit einer Kleinpartei", "Small party",
                                        ifelse(variable == "mit keiner Partei", "none",
                                        ifelse(variable == "sehr stark ", "very strong",
                                        ifelse(variable == "ziemlich stark ", "rather strong",
                                        ifelse(variable == "mäßig ", "PID: medium",
                                        ifelse(variable == "ziemlich schwach ", "rather weak",
                                        ifelse(variable == "sehr schwach ", "very weak",
                                        ifelse(variable == "Maßnahmen ergreifen", "take measures",
                                        ifelse(variable == "habe keine Meinung dazu, ob die Regierung Maßnahmen ergreifen sollte", "no opinion",
                                        ifelse(variable == "keine Maßnahmen ergreifen", "don't take measures",
                                               
                                        ifelse(variable == "erleichtern", "facilitate",
                                        ifelse(variable == "weder erleichtern noch einschränken", "neither nor",
                                        ifelse(variable == "einschränken", "limit", variable)))))))))))))))))))))))))))))))))))))))))))))))

plot_matches_subgroups_2 <- ggplot(data_heatmap_match_2,
                          aes(x = vote,
                          y = variable,
                          fill = mean_prop)) +
  geom_tile() +
  xlab("Vote Choice (GLES)") +
  ylab("Subgroups") +
  scale_x_discrete(limits = c("CDU/CSU", "SPD", "Greens", "FDP", "Left","AfD", "Other party", "No vote")) +
  scale_y_discrete(limits=c("facilitate", "neither nor", "limit","take measures",  "no opinion", "don't take measures",  "very strong", "rather strong", "PID: medium", "rather weak", "very weak",  "none", "Small party", "AfD", "Left", "FDP", "Greens", "SPD", "CDU/CSU", "right", "center-right", "center", "center-left", "left", "very","somewhat", "not very", "not at all", "West Germany", "East Germany", "high", "medium", "low", "working", "studying", "not working", "College", "Abitur", "Realschule", "Hauptschule", "no degree", "male","female", "65+", "35-64", "18-34")) + # reversed order bc plot converts it...
  scale_fill_gradient(low="white", high="#faa32b",
                      limits = c(0, 1),
                      name = "% Match Vote Choice GPT - GLES",
                      labels = scales::label_percent()) +
  theme_minimal() +
  theme(legend.position = "top",
        axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_blank())

#ggsave("heatmap_matches_subgroups_2.png", plot_matches_subgroups_2, height = 7, width = 8)

```

## Individual level: Regression assessing determinants of match, by sample

### TO DO: Maybe as robustness without wronly assigned ineligible folks?

```{r}
# Sample 1
model_match_1 <- glm(match_vote_outcome ~ vote + age + female + edu + emp + hhincome + east + religious + leftright + partyid_degree*partyid + inequality + immigration,
                   data=data_final_numeric_noNA[data_final_numeric_noNA$sample_no == 1, ],
                   family=binomial(link=logit))

## Get coeffs & stderrs
#summary(model_match_1)
#coef(model_match_1)

## Get n: 1827
#length(model_match_vote_1$residuals)


# Sample 2
model_match_2 <- glm(match_vote_outcome ~ vote + age + female + edu + emp + hhincome + east + religious + leftright + partyid_degree*partyid + inequality + immigration,
                   data=data_final_numeric_noNA[data_final_numeric_noNA$sample_no == 2, ],
                   family=binomial(link=logit))

## Get coeffs & stderrs
#summary(model_match_2)
#coef(model_match_2)

## Get n: 1827
#length(model_match_2$residuals)


# Sample 3
model_match_3 <- glm(match_vote_outcome ~ vote+ age + female + edu + emp + hhincome + east + religious + leftright + partyid_degree*partyid + inequality + immigration,
                   data=data_final_numeric_noNA[data_final_numeric_noNA$sample_no == 3, ],
                   family=binomial(link=logit))

## Get coeffs & stderrs
#summary(model_match_3)
#coef(model_match_3)

## Get n: 1827
#length(model_match_3$residuals)


# Sample 4
model_match_4 <- glm(match_vote_outcome ~ vote + age + female + edu + emp + hhincome + east + religious + leftright + partyid_degree*partyid + inequality + immigration,
                   data=data_final_numeric_noNA[data_final_numeric_noNA$sample_no == 4, ],
                   family=binomial(link=logit))

## Get coeffs & stderrs
#summary(model_match_4)
#coef(model_match_4)

## Get n: 1827
#length(model_match_4$residuals)


# Sample 5
model_match_5 <- glm(match_vote_outcome ~ vote + age + female + edu + emp + hhincome + east + religious + leftright + partyid_degree*partyid + inequality + immigration,
                   data=data_final_numeric_noNA[data_final_numeric_noNA$sample_no == 5, ],
                   family=binomial(link=logit))

## Get coeffs & stderrs
#summary(model_match_5)
#coef(model_match_5)

## Get n: 1827
#length(model_match_5$residuals)
```

### Data transformation

```{r}
# Store as 1 df per sample

## Sample 1
data_model_match_1 <- summary(model_match_1)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("variable") %>%
                           mutate(variable = (ifelse(variable == "(Intercept)",
                                                     "intercept",
                                                     variable))) %>%
                           rename(coeff = Estimate) %>%
                           rename(stderr = "Std. Error") %>%
                           rename(z_value = "z value") %>%
                           rename(p_value = "Pr(>|z|)") %>%
                           mutate(sample = 1)

data_model_match_2 <- summary(model_match_2)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("variable") %>%
                           mutate(variable = (ifelse(variable == "(Intercept)",
                                                     "intercept",
                                                     variable))) %>%
                           rename(coeff = Estimate) %>%
                           rename(stderr = "Std. Error") %>%
                           rename(z_value = "z value") %>%
                           rename(p_value = "Pr(>|z|)") %>%
                           mutate(sample = 2)


data_model_match_3 <- summary(model_match_3)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("variable") %>%
                           mutate(variable = (ifelse(variable == "(Intercept)",
                                                     "intercept",
                                                     variable))) %>%
                           rename(coeff = Estimate) %>%
                           rename(stderr = "Std. Error") %>%
                           rename(z_value = "z value") %>%
                           rename(p_value = "Pr(>|z|)") %>%
                           mutate(sample = 3)

data_model_match_4 <- summary(model_match_4)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("variable") %>%
                           mutate(variable = (ifelse(variable == "(Intercept)",
                                                     "intercept",
                                                     variable))) %>%
                           rename(coeff = Estimate) %>%
                           rename(stderr = "Std. Error") %>%
                           rename(z_value = "z value") %>%
                           rename(p_value = "Pr(>|z|)") %>%
                           mutate(sample = 4)

data_model_match_5 <- summary(model_match_5)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("variable") %>%
                           mutate(variable = (ifelse(variable == "(Intercept)",
                                                     "intercept",
                                                     variable))) %>%
                           rename(coeff = Estimate) %>%
                           rename(stderr = "Std. Error") %>%
                           rename(z_value = "z value") %>%
                           rename(p_value = "Pr(>|z|)") %>%
                           mutate(sample = 5)

# Merge in one df across samples
data_model_match_all <- bind_rows(data_model_match_1, data_model_match_2, data_model_match_3, data_model_match_4, data_model_match_5)
data_model_match_all <- data_model_match_all %>% rename(sample_no = sample) # for consistency

```

### Aggregation

```{r}
data_model_match_mean <- data_model_match_all %>%
    group_by(variable) %>%
    summarise(W_coeff = mean(stderr^2), # Within variance OF COEFFICIENT (mean)
              mean_coeff = mean(coeff), # Mean estimate (coefficient)
              B_coeff = var(coeff), # Between variance (coefficient)
              mean_stderr = mean(stderr), # Mean estimate (stderr)
              B_stderr = var(stderr), # Between variance (stderr)
              mean_p = mean(p_value), # Mean estimate (p-value)
              B_p = var(p_value)) %>% # Between variance (p-value)
    mutate(m = 5,
           T = W_coeff + (1 + 1/m) * B_coeff, # total variance (Rubin's rules) OF COEFFICIENT
           T_stderr= sqrt(T)) # standard error OF COEFFICIENT --> to be used for CIs



# Export
export_match <- data_model_match_mean %>%
                   select(variable, mean_coeff, mean_p, T_stderr) %>%
                   mutate(mean_coeff = round(mean_coeff, digits = 3)) %>%
                   mutate(mean_p = round(mean_p, digits = 3)) %>%
                   mutate(T_stderr = round(T_stderr, digits = 3))

write.csv(export_match, "model_match.csv", row.names = F)
```

### Plot

#### TO DO: Change colors (shouldn't be the same as GLES vs GPT)

#### QUESTION:
- Why No-effect-line at 0 even though I specified 1?

```{r}
data_plot_match <- export_match %>%
                          filter(!(is.na(T_stderr))) %>%
                          mutate(lower = mean_coeff - 1.96*T_stderr,
                                 upper = mean_coeff + 1.96*T_stderr,
                                 oddsratio = exp(mean_coeff)) %>%
                          mutate(lower_or = exp(lower),
                                 upper_or = exp(upper)) %>%
                          mutate(sig = ifelse(lower_or > 1 | upper_or < 1, "Significant",
                                              "Not significant")) %>%
                          mutate(variable = ifelse(variable == "intercept", "Intercept",
                                                  ifelse(variable == "voteAfD", "Vote (GLES): AfD",
                                                  ifelse(variable == "voteAndere Partei", "Vote (GLES): Small party",
                                                  ifelse(variable == "voteBündnis 90/Die Grünen", "Vote (GLES): Greens",
                                                  ifelse(variable == "voteDie Linke", "Vote (GLES): Left",
                                                  ifelse(variable == "voteFDP", "Vote (GLES): FDP",
                                                  ifelse(variable == "voteNicht gewählt", "Vote (GLES): No vote",
                                                  ifelse(variable == "voteSPD", "Vote (GLES): SPD",
                                                  ifelse(variable == "voteUngültig gewählt", "Vote (GLES): Invalid",
                                                  ifelse(variable == "age", "Age",
                                                  ifelse(variable == "femaleweiblich", "Gender: female",
                                                  ifelse(variable == "edu", "Education",
                                                  ifelse(variable == "empnicht berufstätig", "Employment: not working",
                                                  ifelse(variable == "empin Ausbildung", "Employment: studying",
                                                  ifelse(variable == "hhincomemittleres", "Income: medium",
                                                  ifelse(variable == "hhincomehohes", "Income: high",
                                                  ifelse(variable == "eastOstdeutschland", "Residence: East Germany",
                                                  ifelse(variable == "religiousnicht sehr religiös", "Religiosity: not very",
                                                  ifelse(variable == "religiousetwas religiös", "Religiosity: somewhat",
                                                  ifelse(variable == "religioussehr religiös", "Religiosity: very",
                                                  ifelse(variable == "leftright", "LR-Ideology",
                                                  ifelse(variable == "partyidSPD", "Party ID: SPD",
                                                  ifelse(variable == "partyidFDP", "Party ID: FDP",
                                                  ifelse(variable == "partyidDie Grünen", "Party ID: Greens",
                                                  ifelse(variable == "partyidDie Linke", "Party ID: Left",
                                                  ifelse(variable == "partyidAfD", "Party ID: AfD",
                                                  ifelse(variable == "partyidKleinpartei", "Party ID: Small party",
                                                  ifelse(variable == "partyidkeine Partei", "Party ID: none",
                                                  ifelse(variable == "partyid_degree", "Strength of Party ID",
                                                  ifelse(variable == "inequalityhabe keine Meinung dazu", "Att. Inequality: no opinion",
                                                  ifelse(variable == "inequalitykeine Maßnahmen ergreifen", "Att. Inequality: don't take measures",
                                                  ifelse(variable == "immigrationweder erleichtern noch einschränken", "Att. Immigration: neither nor",
                                                  ifelse(variable == "immigrationeinschränken", "Att. Immigration: limit",
                                                  ifelse(variable == "partyid_degree:partyidSPD", "Party ID x Strength: SPD",
                                                  ifelse(variable == "partyid_degree:partyidFDP", "Party ID x Strength: FDP",
                                                  ifelse(variable == "partyid_degree:partyidDie Grünen", "Party ID x Strength: Greens",
                                                  ifelse(variable == "partyid_degree:partyidDie Linke", "Party ID x Strength: Left",
                                                  ifelse(variable == "partyid_degree:partyidAfD", "Party ID x Strength: AfD",
                                                  ifelse(variable == "partyid_degree:partyidKleinpartei", "Party ID x Strength: Small party",
                                                  ifelse(variable == "partyidkeine Partei:partyid_degree", "Party ID x Strength: none", variable)))))))))))))))))))))))))))))))))))))))))


plot_model_match <- ggplot(data_plot_match, 
       aes(y = variable,
           x = oddsratio,
           xmin = lower_or,
           xmax = upper_or,
           color = sig)) +      # legend colored by significance
  geom_vline(xintercept = 1,      # reference line at 1 for OR, 0 for pure coeffs
             linetype = "solid",
             linewidth = 0.2) +
  geom_point(aes(color = sig), # point estimate
             size = 2) +
  geom_pointrange(linewidth = 0.5) + # error bars
  scale_x_log10(breaks = scales::trans_breaks("log10", function(x) 10^x),
                labels = scales::trans_format("log10", scales::math_format(.x))) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Vote (GLES): Invalid", "Vote (GLES): No vote", "Vote (GLES): Small party", "Vote (GLES): AfD", "Vote (GLES): Left", "Vote (GLES): FDP", "Vote (GLES): Greens", "Vote (GLES): SPD", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) +
  scale_color_manual(limits = c("Significant", "Not significant"),
                      values = c("Significant" = "#1e31fa",
                                 "Not significant" = "#faa32b")) +
  theme_minimal() +
  labs(
    x = "ß as Odds Ratios (additive effect on log-odds)",
    y = "",
    title = "Determinants of Matching Vote Choice Between GLES and GPT") +
  theme(
        #plot.background = element_rect(fill = "white", color = "white"),
        legend.position = "top",
        legend.title = element_blank())

ggsave("model_match.png", plot_model_match, height = 6, width = 8)

```

```{r}
plot_model_match
```

Significant according to plot:
- vote: FDP (negative)
- vote: AfD (negative)
- vote: small party (negative)
- vote: no vote (negative)
- party ID: FDP (positive)
- party ID: none (positive)
- strength of party ID (positive)
(-Intercept)

### Partisan Voting Analysis

#### TO DO: VarEst for comparing to GPT!?

```{r}
# Partisan voting
round(prop.table(table(data_final_numeric_noNA$vote, data_final_numeric_noNA$partyid), margin = 2), 3)

# Distribution of partisanship
round(prop.table(table(data_final_numeric_noNA$partyid)), 3)

# Distribution of vote
round(prop.table(table(data_final_numeric_noNA$vote)), 3)

# Compare to GPT: need VarEst!

```

# Aggregate: Distribution of vote shares GLES vs. GPT

## Tables

```{r}
# GLES
table_vote_overall_s <- prop.table(table(mc_GLES2017_final$vote, useNA = "always"))

# GPT Overall
table_votegpt_overall_s <- prop.table(table(mc_GLES2017_final$vote_gpt, useNA = "always"))

# GPT Sample 1
table_votegpt_s1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 1], useNA = "always"))

# GPT Sample 2
table_votegpt_s2 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 2], useNA = "always"))

# GPT Sample 3
table_votegpt_s3 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 3], useNA = "always"))

# GPT Sample 4
table_votegpt_s4 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 4], useNA = "always"))

# GPT Sample 5
table_votegpt_s5 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 5], useNA = "always"))


```

## Variance Estimation

```{r}
# Calculate proportions and its variance for each iteration
sample_proportions <- mc_GLES2017_final %>%
    group_by(sample_no, vote_gpt) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(vote_gpt) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

# Calculate the between-iteration variance and total variance
mean_proportions <- sample_proportions %>%
    group_by(vote_gpt) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    arrange(desc(mean_prop))

mean_proportions 
```

## Plot

### TO DO: Change CI colors, change chart colors?
### QUESTION:
- How to remove CIs for GLES but keep labels?

```{r}
#GLES

## Filter the dataset for a specific sample_no
data_vote_1 <- subset(mc_GLES2017_final, sample_no == 1)

## Calculate the relative frequencies of each category
table_vote_freq_1 <- prop.table(table(data_vote_1$vote))

## Sort the categories based on their frequencies
data_vote_freq_1_sorted <- as.data.frame(table_vote_freq_1[order(table_vote_freq_1, decreasing = TRUE)])

data_vote_freq_1_sorted <- data_vote_freq_1_sorted %>%
                           rename(party = Var1) %>%
                           mutate(source = "GLES") %>%
                           mutate(source = as.factor(source)) %>%
                           mutate(T_stderr = NA) %>%
                           rename(freq = Freq)

# Adjust GPT
mean_proportions_df <- mean_proportions %>%
                       select(vote_gpt, mean_prop, T_stderr) %>%
                       rename(party = vote_gpt) %>%
                       rename(freq = mean_prop) %>%
                       replace_na(list(party = "no prediction")) %>%
                       mutate(source = "GPT") %>%
                       #mutate(party = as.factor(party)) %>%
                       mutate(source = factor(source, levels = c("GLES", "GPT")))

# Adjust GLES
data_vote_freq <- data_vote_freq_1_sorted %>%
                  mutate(T_stderr = sqrt(freq * (1-freq)/1905)) %>% # SE if GLES eligible voters could be treated unweighted
                  add_row(party = "no prediction", freq = 0, source = "GLES",
                          T_stderr = NA
                          ) %>%
                  mutate(source = factor(source, levels = c("GLES", "GPT")))

# Merge GLES & GPT, remove small percentage of "no prediction"
data_vote_parties <- bind_rows(mean_proportions_df, data_vote_freq)
data_vote_parties <- data_vote_parties %>%
                      mutate(party = ifelse(party == "Bündnis 90/Die Grünen", "Greens",
                                        ifelse(party == "Die Linke", "Left",
                                        ifelse(party== "Andere Partei", "Small party",
                                        ifelse(party == "Ungültig gewählt", "Invalid vote",
                                        ifelse(party == "Nicht gewählt", "No vote", party))))))  %>%
                      mutate(party = as.factor(party))
data_vote_parties <- data_vote_parties[data_vote_parties$party!="no prediction" , ]

plot_shares_aggregate <- ggplot(data_vote_parties, aes(x = party,
                                                           y = freq,
                                                           fill = source)) +
                      geom_bar(stat = "identity", position = "dodge") +
                      geom_text(aes(label = round(freq*100,1),
                                    y = freq + (1.96*T_stderr) + 0.005), 
                                position = position_dodge(0.9),
                                vjust = 0,
                                color = "black") +
                      xlab("") +
                      ylab("") +
                      scale_x_discrete(limits = c("CDU/CSU", "SPD", "Greens", "FDP", "Left",
                                                  "AfD", "Small party", "Invalid vote",
                                                  "No vote")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      scale_fill_manual(limits = c("GLES", "GPT"),
                                        values = c("GLES" = "#1e31fa", "GPT" = "#faa32b"),
                                        labels = c("GLES (German Longitudinal Election Study)",
                                                   "GPT-3"),
                                        name = "Reported vote choice \naccording to") +
                      #scale_fill_viridis(option = "plasma",
                       #                  discrete = TRUE,
                       #                  limits = c("GLES", "GPT"),
                       #                  labels = c("GLES (German Longitudinal Election Study)",
                       #                            "GPT-3"),
                       #                name = "Reported vote choice \naccording to") +
                      geom_errorbar(aes(x=party,
                                        ymin=freq-(1.96*T_stderr),
                                        ymax=freq+(1.96*T_stderr)),
                                    #data = subset(data_vote_parties, source == "GPT"), # toggle on / off for GLES CIs; Problem: then CIs centered across sources!
                                    width=0.4,
                                    #colour="#0c1aad",
                                    colour = "black",
                                    position = position_dodge(width = 0.9)) +
                      ggtitle("") +
                      theme_minimal() +
                      theme(legend.position = "top",
                            legend.title.align = 1,
                            axis.text.x = element_text(colour = "black"),
                            axis.text.y = element_text(colour = "black"),
                            panel.grid.minor = element_blank(),
                            panel.grid.major = element_blank())


ggsave("shares_aggregate.png", plot_shares_aggregate, height = 4, width = 8)
```

```{r}
plot_shares_aggregate
```

- GPT overestimates the share of Green, Left, and non-voters
- GPT underestimates the share of FDP and AfD voters and voters of other/small parties

## Comparison with actual election result - unweighted

### TO DO: Weight; QUESTION:
- How to add labels for real result without CIs, but still dodged to the top?

Source: https://www.bundeswahlleiterin.de/dam/jcr/56147bb4-c149-4faa-a9b0-9a3d98e8bf7b/btw17_heft5-1.pdf Chart page 30

```{r}
data_vote_real <- data_vote_parties %>%
                  add_row(party = "CDU/CSU", freq = 0.249, T_stderr = NA, source = "Election") %>%
                  add_row(party = "SPD", freq = 0.155, T_stderr = NA, source = "Election") %>%
                  add_row(party = "Greens", freq = 0.067, T_stderr = NA, source = "Election") %>%
                  add_row(party = "FDP", freq = 0.081, T_stderr = NA, source = "Election") %>%
                  add_row(party = "AfD", freq = 0.095, T_stderr = NA, source = "Election") %>%
                  add_row(party = "Left", freq = 0.07, T_stderr = NA, source = "Election") %>%
                  add_row(party = "Small party", freq = 0.038, T_stderr = NA, source = "Election") %>%
                  add_row(party = "Invalid vote", freq = 0.007, T_stderr = NA, source = "Election") %>%
                  add_row(party = "No vote", freq = 0.238, T_stderr = NA, source = "Election")

plot_shares_real <-   ggplot(data_vote_real, aes(x = party,
                                                    y = freq,
                                                    fill = source)) +
                      geom_bar(stat = "identity", position = "dodge") +
                      geom_text(aes(label = round(freq*100,1),
                                    y = freq + (1.96*T_stderr) + 0.005), 
                                position = position_dodge(0.9),
                                vjust = 0,
                                color = "black") +
                      xlab("") +
                      ylab("") +
                      scale_x_discrete(limits = c("CDU/CSU", "SPD", "Greens", "FDP", "Left",
                                                  "AfD", "Small party", "Invalid vote",
                                                  "No vote")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      scale_fill_manual(limits = c("Election", "GLES", "GPT"),
                                        values = c("Election" = "grey",
                                                   "GLES" = "#1e31fa",
                                                   "GPT" = "#faa32b"),
                                        labels = c("Official Result", 
                                                   "GLES (German Longitudinal Election Study)",
                                                   "GPT-3"
                                                   ),
                                        name = "Vote choice \naccording to") +
                      #scale_fill_viridis(option = "plasma",
                       #                  discrete = TRUE,
                       #                  limits = c("GLES", "GPT"),
                       #                  labels = c("GLES (German Longitudinal Election Study)",
                       #                            "GPT-3"),
                       #                name = "Reported vote choice \naccording to") +
                      geom_errorbar(aes(x=party,
                                        ymin=freq-(1.96*T_stderr),
                                        ymax=freq+(1.96*T_stderr)),
                                    width=0.4,
                                    #colour="#0c1aad",
                                    colour = "black",
                                    position = position_dodge(width = 0.9)) +
                      ggtitle("") +
                      theme_minimal() +
                      theme(legend.position = "top",
                            legend.title.align = 1,
                            axis.text.x = element_text(colour = "black"),
                            axis.text.y = element_text(colour = "black"),
                            panel.grid.minor = element_blank(),
                            panel.grid.major = element_blank())
```

```{r}
plot_shares_real
```

- Two truths:
- For parties that GPT underestimates compared to GLES (FDP, AfD, small parties), GLES is closer to the real result / real result is in GLES, but not GPT CI - BUT except FDP! Re-evaluate variables for FDP in GPT regression models?
- For parties that GPT overestimates compared to GLES (Green, Left, non-voters), GLES is closer to the real result - BUT except non-voters! Confirms issue with GLES in getting non-voters

--> New paper: using GPT to forecast abstention / Wahlbeteiligung? --> What factors influence likely voting?

# VOTE: Comparing determinants of vote choice

Notes from https://stackoverflow.com/questions/43623076/multinomial-logit-in-r-mlogit-versus-nnet
In nnet::multinom the model is a neural network with no hidden layers, no bias nodes and a softmax output layer.
Maximum conditional likelihood is the method used in multinom for model fitting.

For models estimated by multinom the McFadden's pseudo R-squared can be easily calculated as follows:
nnet.mod.loglik <- nnet:::logLik.multinom(nnet.mod)
nnet.mod0 <- multinom(y ~ 1, df1)
nnet.mod0.loglik <- nnet:::logLik.multinom(nnet.mod0)
nnet.mod.mfr2 <- as.numeric(1 - nnet.mod.loglik/nnet.mod0.loglik)

## GPT: Regressions by sample

### QUESTION:
- DV = Ungültig gewählt from sample 2 not in dataset, i.e. not part of n for means! Ok or should be 0?
Warning: group ‘Ungültig gewählt’ is empty# weights:  264 (224 variable)

```{r}
# Sample 1
model_vote_gpt_1 <- multinom(vote_gpt ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration, data = data_final_numeric_noNA, subset = data_final_numeric_noNA$sample_no == 1)

## Get coeffs & stderrs
#summary(model_vote_gpt_1)
#coef(model_vote_gpt_1)

## Get n: 1827
#nrow(residuals(model_vote_gpt_1))


# Sample 2
model_vote_gpt_2 <- multinom(vote_gpt ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration, data = data_final_numeric_noNA, subset = data_final_numeric_noNA$sample_no == 2)

## Get coeffs & stderrs
#summary(model_vote_gpt_2)
#coef(model_vote_gpt_2)

## Get n: 1827
#nrow(residuals(model_vote_gpt_2))


# Sample 3
model_vote_gpt_3 <- multinom(vote_gpt ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration, data = data_final_numeric_noNA, subset = data_final_numeric_noNA$sample_no == 3)

## Get coeffs & stderrs
#summary(model_vote_gpt_3)
#coef(model_vote_gpt_3)

## Get n: 1827
#nrow(residuals(model_vote_gpt_3))


# Sample 4
model_vote_gpt_4 <- multinom(vote_gpt ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration, data = data_final_numeric_noNA, subset = data_final_numeric_noNA$sample_no == 4)

## Get coeffs & stderrs
#summary(model_vote_gpt_4)
#coef(model_vote_gpt_4)

## Get n: 1827
#nrow(residuals(model_vote_gpt_4))


# Sample 5
model_vote_gpt_5 <- multinom(vote_gpt ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration, data = data_final_numeric_noNA, subset = data_final_numeric_noNA$sample_no == 5)

## Get coeffs & stderrs
#summary(model_vote_gpt_5)
#coef(model_vote_gpt_5)

## Get n: 1827
#nrow(residuals(model_vote_gpt_5))
```

### Data transformation

```{r}
# Get coeffs, std.errors & test statistics, transform into long format & store as 1 df per sample

## Sample 1
coeff_model_vote_gpt_1 <- summary(model_vote_gpt_1)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "coeff")

stderr_model_vote_gpt_1 <- summary(model_vote_gpt_1)$standard.errors %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "stderr")

z_model_vote_gpt_1 <- summary(model_vote_gpt_1)$coefficients/summary(model_vote_gpt_1)$standard.errors
# cannot transform before calculating p-values

# have to do separately because %>% doesn't work with calculation
p_model_vote_gpt_1 <- (1 - pnorm(abs(z_model_vote_gpt_1), 0, 1)) * 2 # 2-tailed z-test 
p_model_vote_gpt_1 <- p_model_vote_gpt_1 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "p_value")


z_model_vote_gpt_1 <- z_model_vote_gpt_1 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "z_value")

data_model_vote_gpt_1 <- coeff_model_vote_gpt_1 %>%
                         left_join(stderr_model_vote_gpt_1, by = c("party", "variable")) %>%
                         left_join(p_model_vote_gpt_1, by = c("party", "variable")) %>%
                         left_join(z_model_vote_gpt_1, by = c("party", "variable")) %>%
                         mutate(sample = 1)


## Sample 2

coeff_model_vote_gpt_2 <- summary(model_vote_gpt_2)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "coeff")

stderr_model_vote_gpt_2 <- summary(model_vote_gpt_2)$standard.errors %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "stderr")

z_model_vote_gpt_2 <- summary(model_vote_gpt_2)$coefficients/summary(model_vote_gpt_2)$standard.errors
# cannot transform before calculating p-values

# have to do separately because %>% doesn't work with calculation
p_model_vote_gpt_2 <- (1 - pnorm(abs(z_model_vote_gpt_2), 0, 1)) * 2 # 2-tailed z-test 
p_model_vote_gpt_2 <- p_model_vote_gpt_2 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "p_value")


z_model_vote_gpt_2 <- z_model_vote_gpt_2 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "z_value")

data_model_vote_gpt_2 <- coeff_model_vote_gpt_2 %>%
                         left_join(stderr_model_vote_gpt_2, by = c("party", "variable")) %>%
                         left_join(p_model_vote_gpt_2, by = c("party", "variable")) %>%
                         left_join(z_model_vote_gpt_2, by = c("party", "variable")) %>%
                         mutate(sample = 2)

## Sample 3

coeff_model_vote_gpt_3 <- summary(model_vote_gpt_3)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "coeff")

stderr_model_vote_gpt_3 <- summary(model_vote_gpt_3)$standard.errors %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "stderr")

z_model_vote_gpt_3 <- summary(model_vote_gpt_3)$coefficients/summary(model_vote_gpt_3)$standard.errors
# cannot transform before calculating p-values

# have to do separately because %>% doesn't work with calculation
p_model_vote_gpt_3 <- (1 - pnorm(abs(z_model_vote_gpt_3), 0, 1)) * 2 # 2-tailed z-test 
p_model_vote_gpt_3 <- p_model_vote_gpt_3 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "p_value")


z_model_vote_gpt_3 <- z_model_vote_gpt_3 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "z_value")

data_model_vote_gpt_3 <- coeff_model_vote_gpt_3 %>%
                         left_join(stderr_model_vote_gpt_3, by = c("party", "variable")) %>%
                         left_join(p_model_vote_gpt_3, by = c("party", "variable")) %>%
                         left_join(z_model_vote_gpt_3, by = c("party", "variable")) %>%
                         mutate(sample = 3)

## Sample 4

coeff_model_vote_gpt_4 <- summary(model_vote_gpt_4)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "coeff")

stderr_model_vote_gpt_4 <- summary(model_vote_gpt_4)$standard.errors %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "stderr")

z_model_vote_gpt_4 <- summary(model_vote_gpt_4)$coefficients/summary(model_vote_gpt_4)$standard.errors
# cannot transform before calculating p-values

# have to do separately because %>% doesn't work with calculation
p_model_vote_gpt_4 <- (1 - pnorm(abs(z_model_vote_gpt_4), 0, 1)) * 2 # 2-tailed z-test 
p_model_vote_gpt_4 <- p_model_vote_gpt_4 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "p_value")


z_model_vote_gpt_4 <- z_model_vote_gpt_4 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "z_value")

data_model_vote_gpt_4 <- coeff_model_vote_gpt_4 %>%
                         left_join(stderr_model_vote_gpt_4, by = c("party", "variable")) %>%
                         left_join(p_model_vote_gpt_4, by = c("party", "variable")) %>%
                         left_join(z_model_vote_gpt_4, by = c("party", "variable")) %>%
                         mutate(sample = 4)

## Sample 5

coeff_model_vote_gpt_5 <- summary(model_vote_gpt_5)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "coeff")

stderr_model_vote_gpt_5 <- summary(model_vote_gpt_5)$standard.errors %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "stderr")

z_model_vote_gpt_5 <- summary(model_vote_gpt_5)$coefficients/summary(model_vote_gpt_5)$standard.errors
# cannot transform before calculating p-values

# have to do separately because %>% doesn't work with calculation
p_model_vote_gpt_5 <- (1 - pnorm(abs(z_model_vote_gpt_5), 0, 1)) * 2 # 2-tailed z-test 
p_model_vote_gpt_5 <- p_model_vote_gpt_5 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "p_value")


z_model_vote_gpt_5 <- z_model_vote_gpt_5 %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "z_value")

data_model_vote_gpt_5 <- coeff_model_vote_gpt_5 %>%
                         left_join(stderr_model_vote_gpt_5, by = c("party", "variable")) %>%
                         left_join(p_model_vote_gpt_5, by = c("party", "variable")) %>%
                         left_join(z_model_vote_gpt_5, by = c("party", "variable")) %>%
                         mutate(sample = 5)

# Merge in one df across samples
data_model_vote_gpt_all <- bind_rows(data_model_vote_gpt_1, data_model_vote_gpt_2, data_model_vote_gpt_3, data_model_vote_gpt_4, data_model_vote_gpt_5)
data_model_vote_gpt_all <- data_model_vote_gpt_all %>% rename(sample_no = sample) # for consistency
```

### Aggregation

```{r}
data_model_vote_gpt_mean <- data_model_vote_gpt_all %>%
    group_by(party, variable) %>%
    summarise(W_coeff = mean(stderr^2), # Within variance OF COEFFICIENT (mean)
              mean_coeff = mean(coeff), # Mean estimate (coefficient)
              B_coeff = var(coeff), # Between variance (coefficient)
              mean_stderr = mean(stderr), # Mean estimate (stderr)
              B_stderr = var(stderr), # Between variance (stderr)
              mean_p = mean(p_value), # Mean estimate (p-value)
              B_p = var(p_value)) %>% # Between variance (p-value)
    mutate(m = 5,
           T = W_coeff + (1 + 1/m) * B_coeff, # total variance (Rubin's rules) OF COEFFICIENT
           T_stderr= sqrt(T)) # standard error OF COEFFICIENT --> to be used for CIs



# Export
export_vote_gpt <- data_model_vote_gpt_mean %>%
                   select(party, variable, mean_coeff, mean_p) %>%
                   mutate(mean_coeff = round(mean_coeff, digits = 3)) %>%
                   mutate(mean_p = round(mean_p, digits = 3)) %>%
                   pivot_wider(names_from = party,
                               values_from = all_of(c("mean_coeff",
                                                      "mean_p")),
                               names_sep = "_")

write.csv(export_vote_gpt, "model_vote_gpt.csv", row.names = F)

```

### Plot

```{r}
data_plot_vote_gpt <- data_model_vote_gpt_mean %>%
                          select(party, variable, mean_coeff, mean_p, T_stderr) %>%
                          filter(!(is.na(T_stderr))) %>%
                          mutate(lower = mean_coeff - 1.96*T_stderr,
                                 upper = mean_coeff + 1.96*T_stderr,
                                 oddsratio = exp(mean_coeff)) %>%
                          mutate(lower_or = exp(lower),
                                 upper_or = exp(upper)) %>%
                          mutate(sig = ifelse(lower_or > 1 | upper_or < 1, "Significant",
                                              "Not significant")) %>%
                          mutate(party = ifelse(party == "Bündnis 90/Die Grünen", "Greens",
                                         ifelse(party == "Die Linke", "Left",
                                         ifelse(party == "Andere Partei", "Other party",
                                         ifelse(party == "Ungültig gewählt", "Invalid vote",
                                         ifelse(party == "Nicht gewählt", "No vote", party)))))) %>%
                          mutate(party = factor(party,
                                          levels = c("SPD", "Greens", "FDP", "Left","AfD", "Other party", "Invalid vote", "No vote"))) %>%
                          mutate(variable = ifelse(variable == "intercept", "Intercept",
                                                  ifelse(variable == "age", "Age",
                                                  ifelse(variable == "femaleweiblich", "Gender: female",
                                                  ifelse(variable == "edu", "Education",
                                                  ifelse(variable == "empnicht berufstätig", "Employment: not working",
                                                  ifelse(variable == "empin Ausbildung", "Employment: studying",
                                                  ifelse(variable == "hhincomemittleres", "Income: medium",
                                                  ifelse(variable == "hhincomehohes", "Income: high",
                                                  ifelse(variable == "eastOstdeutschland", "Residence: East Germany",
                                                  ifelse(variable == "religiousnicht sehr religiös", "Religiosity: not very",
                                                  ifelse(variable == "religiousetwas religiös", "Religiosity: somewhat",
                                                  ifelse(variable == "religioussehr religiös", "Religiosity: very",
                                                  ifelse(variable == "leftright", "LR-Ideology",
                                                  ifelse(variable == "partyidSPD", "Party ID: SPD",
                                                  ifelse(variable == "partyidFDP", "Party ID: FDP",
                                                  ifelse(variable == "partyidDie Grünen", "Party ID: Greens",
                                                  ifelse(variable == "partyidDie Linke", "Party ID: Left",
                                                  ifelse(variable == "partyidAfD", "Party ID: AfD",
                                                  ifelse(variable == "partyidKleinpartei", "Party ID: Small party",
                                                  ifelse(variable == "partyidkeine Partei", "Party ID: none",
                                                  ifelse(variable == "partyid_degree", "Strength of Party ID",
                                                  ifelse(variable == "inequalityhabe keine Meinung dazu", "Att. Inequality: no opinion",
                                                  ifelse(variable == "inequalitykeine Maßnahmen ergreifen", "Att. Inequality: don't take measures",
                                                  ifelse(variable == "immigrationweder erleichtern noch einschränken", "Att. Immigration: neither nor",
                                                  ifelse(variable == "immigrationeinschränken", "Att. Immigration: limit",
                                                  ifelse(variable == "partyidSPD:partyid_degree", "Party ID x Strength: SPD",
                                                  ifelse(variable == "partyidFDP:partyid_degree", "Party ID x Strength: FDP",
                                                  ifelse(variable == "partyidDie Grünen:partyid_degree", "Party ID x Strength: Greens",
                                                  ifelse(variable == "partyidDie Linke:partyid_degree", "Party ID x Strength: Left",
                                                  ifelse(variable == "partyidAfD:partyid_degree", "Party ID x Strength: AfD",
                                                  ifelse(variable == "partyidKleinpartei:partyid_degree", "Party ID x Strength: Small party",
                                                  ifelse(variable == "partyidkeine Partei:partyid_degree", "Party ID x Strength: none", variable)))))))))))))))))))))))))))))))))


plot_vote_gpt <- ggplot(data_plot_vote_gpt, 
       aes(y = variable,
           x = oddsratio,
           xmin = lower_or,
           xmax = upper_or,
           color = sig)) +      # legend colored by significance
  geom_vline(xintercept = 1,      # reference line at 1 for OR, 0 for pure coeffs
             linetype = "solid",
             linewidth = 0.2) +
  geom_point(aes(color = sig), # point estimate
             size = 2) +
  geom_pointrange(linewidth = 0.5) + # error bars
  scale_x_log10(breaks = scales::trans_breaks("log10", function(x) 10^x),
                labels = scales::trans_format("log10", scales::math_format(.x))) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: none", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) +
  scale_color_manual(limits = c("Significant", "Not significant"),
                      values = c("Significant" = "#1e31fa", "Not significant" = "#faa32b")) +
  facet_grid(.~party) +
  theme_minimal() +
  labs(
    x = "ß as Odds Ratios (additive effect on log-odds)",
    y = "",
    title = "Determinants of Vote Choice: GPT") +
  theme(
        #plot.background = element_rect(fill = "white", color = "white"),
        legend.position = "top",
        legend.title = element_blank())
```

## GLES

```{r}
data_onesample <- data_final_numeric_noNA[data_final_numeric_noNA$sample_no == 1,]

model_vote_gles <- multinom(vote ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration, data = data_onesample, na.action = na.omit)

summary(model_vote_gles)


# Get coeffs, std.errors & test statistics, transform into long format & store as 1 df
coeff_model_vote_gles <- summary(model_vote_gles)$coefficients %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "coeff")

stderr_model_vote_gles <- summary(model_vote_gles)$standard.errors %>%
                           as.data.frame() %>%
                           rownames_to_column("party") %>%
                           rename(intercept = "(Intercept)") %>%
                           pivot_longer(cols = !party, names_to = "variable", values_to = "stderr")

z_model_vote_gles <- summary(model_vote_gles)$coefficients/summary(model_vote_gles)$standard.errors # Wald Z
# cannot transform before calculating p-values

# have to do separately because %>% doesn't work with calculation
p_model_vote_gles <- (1 - pnorm(abs(z_model_vote_gles), 0, 1)) * 2 # 2-tailed z-test 
p_model_vote_gles <- p_model_vote_gles %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "p_value")

z_model_vote_gles <- z_model_vote_gles %>%
                      as.data.frame() %>%
                      rownames_to_column("party") %>%
                      rename(intercept = "(Intercept)") %>%
                      pivot_longer(cols = !party, names_to = "variable", values_to = "z_value")

data_model_vote_gles <- coeff_model_vote_gles %>%
                         left_join(stderr_model_vote_gles, by = c("party", "variable")) %>%
                         left_join(p_model_vote_gles, by = c("party", "variable")) %>%
                         left_join(z_model_vote_gles, by = c("party", "variable"))

# Pseudo-R2: 0.4156
model_vote_gles_loglik <- nnet:::logLik.multinom(model_vote_gles)
model_0 <- multinom(vote ~ 1, data = data_onesample)
model_0_loglik <- nnet:::logLik.multinom(model_0)
model_vote_gles_r2 <- as.numeric(1 - model_vote_gles_loglik/model_0_loglik)

# Export
stargazer(model_vote_gles,
          title = "Determinants of Vote Choice: GLES",
          dep.var.caption = "Dependent variable: Vote (GLES) – Reference: CDU/CSU",
          dep.var.labels.include = FALSE,
          model.numbers = FALSE,
          column.labels = c("SPD", "Greens", "FDP", "Left", "AfD",
                            "Other Party", "Invalid vote", "No vote"),
          covariate.labels = c("Age", "Gender: Female", "Education",
                              "Employment: not working", "Employment: studying",
                              "Income: medium", "Income: high", "East Germany",
                              "Religiosity: not very", "Religiosity: somewhat",
                              "Religiosity: very", "LR-Ideology",
                              "Party ID: SPD", "Party ID: FDP", "Party ID: Greens",
                              "Party ID: Left", "Party ID: AfD", "Party ID: Small party",
                              "Party ID: none", "Strength of Party ID",
                              "Inequality: no opinion", "Inequality: don't act",
                              "Immigration: neither nor", "Immigration: limit",
                              "Party ID x Strength: SPD", "Party ID x Strength: FDP",
                              "Party ID x Strength: Greens", "Party ID x Strength: Left",
                              "Party ID x Strength: AfD", "Party ID x Strength: Small party",
                              "Party ID x Strength: none"),
          report = "vc*",
          star.cutoffs = c(0.05, 0.01, 0.001),
          add.lines = list(c("Observations", "1827"), c("Pseudo-R2","0.4156")),
          type = "html",
          out = "model_vote_gles.html",
          summary = TRUE,
          digits = 3
          )

```

### Plot

Transforms log-odds coefficients into odds ratios, i.e. already exp(beta)

#### QUESTION:

- Why doesn't interaction term renaming work?

```{r}
plot_vote_gles <- ggcoef_multinom(model_vote_gles,
                                  exponentiate = TRUE,
                                  variable_labels = c(
                                    age = "Age",
                                    female = "Gender (Ref.: male)",
                                    edu = "Education",
                                    emp = "Employment Status (Ref.: working)",
                                    hhincome = "Household Income (Ref.: low)",
                                    east = "Residence (Ref.: West Germany)",
                                    religious = "Religiosity (Ref.: not at all)",
                                    leftright = "LR-Ideology",
                                    partyid = "Party ID (Ref.: CDU/CSU)",
                                    partyid_degree = "Strength of Party ID",
                                    inequality = "Attitude: Inequality (Ref.: take measures)",
                                    immigration = "Attitude: Immigration (Ref.: foster)"#,
                                  #  partyid*partyid_degree = "Party ID x Strength" # not working?
                                   ),
                                  #facet_labeller = ggplot2::label_wrap_gen(20),
                                  add_reference_rows = FALSE,
                                  type = "faceted"
                                  ) +
                  xlab("ß as Odds Ratios (additive effect on log-odds)") +
                  ggtitle("Determinants of Vote Choice: GLES")
```

## Comparing GLES and GPT models

### Data transformation

```{r}
data_model_vote_gles_merge <- data_model_vote_gles %>%
                              select(!z_value) %>%
                              mutate(model = "GLES")

data_model_vote_gpt_merge <- data_model_vote_gpt_mean %>%
                             select(!starts_with("B")) %>%
                             select(!starts_with("W")) %>%
                             select(!m) %>%
                             select(!T) %>%
                             select(!mean_stderr) %>%
                             rename(coeff = mean_coeff) %>%
                             rename(p_value = mean_p) %>%
                             rename (stderr = T_stderr) %>%
                             mutate(model = "GPT")

data_model_vote_merge <- bind_rows(data_model_vote_gles_merge, data_model_vote_gpt_merge)
data_model_vote_merge <- data_model_vote_merge %>%
                         pivot_wider(names_from = model,
                               values_from = all_of(c("coeff",
                                                      "p_value",
                                                      "stderr")),
                               names_sep = "_") %>%
                         mutate(diff_coeff = round(coeff_GPT - coeff_GLES, digits = 3)) %>%
                         mutate(diff_coeff_norm = round(((coeff_GPT - coeff_GLES)/coeff_GLES), digits = 3)) %>%
                         mutate(diff_p = round(p_value_GPT - p_value_GLES, digits = 3)) %>%
                         mutate(or_GPT = exp(coeff_GPT)) %>%
                         mutate(or_GLES = exp(coeff_GLES)) %>%
                         mutate(diff_or = round(or_GPT - or_GLES, digits = 3)) %>%
                         mutate(diff_or_norm = round(((or_GPT - or_GLES)/or_GLES), digits = 3)) %>%
                         mutate(sig = ifelse(p_value_GLES < 0.05 & p_value_GPT >= 0.05, "GLES",
                                             ifelse(p_value_GPT < 0.05 & p_value_GLES >= 0.05, "GPT",
                                                    ifelse(p_value_GLES < 0.05 & p_value_GPT < 0.05, "Both",
                                                           ifelse(p_value_GLES >= 0.05 & p_value_GPT >=0.05, "None", "check"))))) %>%
                         mutate(party = ifelse(party == "Bündnis 90/Die Grünen", "Greens",
                                        ifelse(party == "Die Linke", "Left",
                                        ifelse(party == "Andere Partei", "Other party",
                                        ifelse(party == "Ungültig gewählt", "Invalid vote",
                                        ifelse(party == "Nicht gewählt", "No vote", party)))))) %>%
                         mutate(variable = ifelse(variable == "intercept", "Intercept",
                                                  ifelse(variable == "age", "Age",      
                                                  ifelse(variable == "femaleweiblich", "Gender: female",
                                                  ifelse(variable == "edu", "Education",
                                                  ifelse(variable == "empnicht berufstätig", "Employment: not working",
                                                  ifelse(variable == "empin Ausbildung", "Employment: studying",
                                                  ifelse(variable == "hhincomemittleres", "Income: medium",
                                                  ifelse(variable == "hhincomehohes", "Income: high",
                                                  ifelse(variable == "eastOstdeutschland", "Residence: East Germany",
                                                  ifelse(variable == "religiousnicht sehr religiös", "Religiosity: not very",
                                                  ifelse(variable == "religiousetwas religiös", "Religiosity: somewhat",
                                                  ifelse(variable == "religioussehr religiös", "Religiosity: very",
                                                  ifelse(variable == "leftright", "LR-Ideology",
                                                  ifelse(variable == "partyidSPD", "Party ID: SPD",
                                                  ifelse(variable == "partyidFDP", "Party ID: FDP",
                                                  ifelse(variable == "partyidDie Grünen", "Party ID: Greens",
                                                  ifelse(variable == "partyidDie Linke", "Party ID: Left",
                                                  ifelse(variable == "partyidAfD", "Party ID: AfD",
                                                  ifelse(variable == "partyidKleinpartei", "Party ID: Small party",
                                                  ifelse(variable == "partyidkeine Partei", "Party ID: none",
                                                  ifelse(variable == "partyid_degree", "Strength of Party ID",
                                                  ifelse(variable == "inequalityhabe keine Meinung dazu", "Att. Inequality: no opinion",
                                                  ifelse(variable == "inequalitykeine Maßnahmen ergreifen", "Att. Inequality: don't take measures",
                                                  ifelse(variable == "immigrationweder erleichtern noch einschränken", "Att. Immigration: neither nor",
                                                  ifelse(variable == "immigrationeinschränken", "Att. Immigration: limit",
                                                  ifelse(variable == "partyidSPD:partyid_degree", "Party ID x Strength: SPD",
                                                  ifelse(variable == "partyidFDP:partyid_degree", "Party ID x Strength: FDP",
                                                  ifelse(variable == "partyidDie Grünen:partyid_degree", "Party ID x Strength: Greens",
                                                  ifelse(variable == "partyidDie Linke:partyid_degree", "Party ID x Strength: Left",
                                                  ifelse(variable == "partyidAfD:partyid_degree", "Party ID x Strength: AfD",
                                                  ifelse(variable == "partyidKleinpartei:partyid_degree", "Party ID x Strength: Small party",
                                                  ifelse(variable == "partyidkeine Partei:partyid_degree", "Party ID x Strength: none", variable)))))))))))))))))))))))))))))))))
```

### Plot difference in coefficients (TO DO: sig only?)

```{r}
plot_diff_coeff <- ggplot(data_model_vote_merge,
                          aes(x = party,
                          y = variable,
                          fill = diff_coeff)) +
  geom_tile() +
  xlab("DV: Vote Choice") +
  ylab("IVs") +
  scale_x_discrete(limits = c("SPD", "Greens", "FDP", "Left","AfD", "Other party", "Invalid vote", "No vote")) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: none", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) + # reversed order bc plot converts it...
  scale_fill_gradient2(low="#1e31fa", # GLES puts more weight
                       mid = "white",
                       high="#faa32b", # GPT puts more weight
                       name = "Estimate Difference: \nGPT - GLES") +
  theme_minimal()

ggsave("heatmap_diff_coeff.png", plot_diff_coeff, height = 4, width = 9.5)

#summary(data_model_vote_merge$diff_coeff)
#    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
#-13.8580  -0.9493  -0.0390  -0.4186   0.6797  10.1900 

# Normalized by GLES coeffs
plot_diff_coeff_norm <- ggplot(data_model_vote_merge,
                          aes(x = party,
                          y = variable,
                          fill = diff_coeff_norm)) +
  geom_tile() +
  xlab("DV: Vote Choice") +
  ylab("IVs") +
  scale_x_discrete(limits = c("SPD", "Greens", "FDP", "Left","AfD", "Other party", "Invalid vote", "No vote")) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: none", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) + # reversed order bc plot converts it...
  scale_fill_gradient2(low="#1e31fa", # GLES puts more weight
                       mid = "white",
                       high="#faa32b", # GPT puts more weight
                       #trans = "log10",
                       name = "Estimate Difference: \n(GPT - GLES)/GLES") +
  theme_minimal()

ggsave("heatmap_diff_coeff_norm.png", plot_diff_coeff_norm, height = 4, width = 9.5)
```

```{r}
plot_diff_coeff
```

```{r}
plot_diff_coeff_norm
```

### Plot difference in odds ratios (TO DO: sig only?)

```{r}
plot_diff_or <- ggplot(data_model_vote_merge,
                          aes(x = party,
                          y = variable,
                          fill = diff_or)) +
  geom_tile() +
  xlab("DV: Vote Choice") +
  ylab("IVs") +
  scale_x_discrete(limits = c("SPD", "Greens", "FDP", "Left","AfD", "Other party", "Invalid vote", "No vote")) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: none", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) + # reversed order bc plot converts it...
  scale_fill_gradient2(low="#1e31fa", # GLES puts more weight
                       mid = "white",
                       high="#faa32b", # GPT puts more weight
                       name = "Odds Ratio Difference: \nGPT - GLES") +
  theme_minimal()

ggsave("heatmap_diff_or.png", plot_diff_or, height = 4, width = 9.5)

# summary(data_model_vote_merge$diff_or)
#     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. 
#-3046.386    -0.533    -0.034     9.627     0.553  4867.298

# Normalized by GLES coeffs
plot_diff_or_norm <- ggplot(data_model_vote_merge,
                          aes(x = party,
                          y = variable,
                          fill = diff_or_norm)) +
  geom_tile() +
  xlab("DV: Vote Choice") +
  ylab("IVs") +
  scale_x_discrete(limits = c("SPD", "Greens", "FDP", "Left","AfD", "Other party", "Invalid vote", "No vote")) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: none", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) + # reversed order bc plot converts it...
  scale_fill_gradient2(low="#1e31fa", # GLES puts more weight
                       mid = "white",
                       high="#faa32b", # GPT puts more weight
                       #trans = "log10",
                       name = "Odds Ratio Difference: \n(GPT - GLES)/GLES") +
  theme_minimal()

ggsave("heatmap_diff_or_norm.png", plot_diff_or_norm, height = 4, width = 9.5)

```

```{r}
plot_diff_or
```

```{r}
plot_diff_or_norm
```

### Plot coeffs & CIs, only significant vars

#### QUESTIONS:
- Why no errorbar for some? Too small?
- Why No-effect-line at 0 even though I specified 1?
- Why dot shape change not working?

```{r}
data_plot_vote_compare <- bind_rows(data_model_vote_gles_merge, data_model_vote_gpt_merge) %>%
                          filter(!(is.na(stderr))) %>%
                          mutate(lower = coeff - 1.96*stderr,
                                 upper = coeff + 1.96*stderr,
                                 oddsratio = exp(coeff)) %>%
                          mutate(lower_or = exp(lower),
                                 upper_or = exp(upper)) %>%
                          mutate(sig = ifelse(lower_or > 1 | upper_or < 1, "Significant",
                                              "Not significant")) %>%
                          mutate(party = ifelse(party == "Bündnis 90/Die Grünen", "Greens",
                                         ifelse(party == "Die Linke", "Left",
                                         ifelse(party == "Andere Partei", "Other party",
                                         ifelse(party == "Ungültig gewählt", "Invalid vote",
                                         ifelse(party == "Nicht gewählt", "No vote", party)))))) %>%
                          mutate(party = factor(party,
                                          levels = c("SPD", "Greens", "FDP", "Left","AfD", "Other party", "Invalid vote", "No vote"))) %>%
                          mutate(variable = ifelse(variable == "intercept", "Intercept",
                                                  ifelse(variable == "age", "Age",
                                                  ifelse(variable == "I(age^2)", "Age (squared)",       
                                                  ifelse(variable == "femaleweiblich", "Gender: female",
                                                  ifelse(variable == "edu", "Education",
                                                  ifelse(variable == "empnicht berufstätig", "Employment: not working",
                                                  ifelse(variable == "empin Ausbildung", "Employment: studying",
                                                  ifelse(variable == "hhincomemittleres", "Income: medium",
                                                  ifelse(variable == "hhincomehohes", "Income: high",
                                                  ifelse(variable == "eastOstdeutschland", "Residence: East Germany",
                                                  ifelse(variable == "religiousnicht sehr religiös", "Religiosity: not very",
                                                  ifelse(variable == "religiousetwas religiös", "Religiosity: somewhat",
                                                  ifelse(variable == "religioussehr religiös", "Religiosity: very",
                                                  ifelse(variable == "leftright", "LR-Ideology",
                                                  ifelse(variable == "partyidSPD", "Party ID: SPD",
                                                  ifelse(variable == "partyidFDP", "Party ID: FDP",
                                                  ifelse(variable == "partyidDie Grünen", "Party ID: Greens",
                                                  ifelse(variable == "partyidDie Linke", "Party ID: Left",
                                                  ifelse(variable == "partyidAfD", "Party ID: AfD",
                                                  ifelse(variable == "partyidKleinpartei", "Party ID: Small party",
                                                  ifelse(variable == "partyidkeine Partei", "Party ID: none",
                                                  ifelse(variable == "partyid_degree", "Strength of Party ID",
                                                  ifelse(variable == "inequalityhabe keine Meinung dazu", "Att. Inequality: no opinion",
                                                  ifelse(variable == "inequalitykeine Maßnahmen ergreifen", "Att. Inequality: don't take measures",
                                                  ifelse(variable == "immigrationweder erleichtern noch einschränken", "Att. Immigration: neither nor",
                                                  ifelse(variable == "immigrationeinschränken", "Att. Immigration: limit",
                                                  ifelse(variable == "partyidSPD:partyid_degree", "Party ID x Strength: SPD",
                                                  ifelse(variable == "partyidFDP:partyid_degree", "Party ID x Strength: FDP",
                                                  ifelse(variable == "partyidDie Grünen:partyid_degree", "Party ID x Strength: Greens",
                                                  ifelse(variable == "partyidDie Linke:partyid_degree", "Party ID x Strength: Left",
                                                  ifelse(variable == "partyidAfD:partyid_degree", "Party ID x Strength: AfD",
                                                  ifelse(variable == "partyidKleinpartei:partyid_degree", "Party ID x Strength: Small party",
                                                  ifelse(variable == "partyidkeine Partei:partyid_degree", "Party ID x Strength: none", variable))))))))))))))))))))))))))))))))))

# Plot
plot_vote_compare <- ggplot(data_plot_vote_compare[data_plot_vote_compare$sig == "Significant",], 
       aes(y = variable,
           x = oddsratio,
           xmin = lower_or,
           xmax = upper_or,
           color = model)) +      # legend colored by model
  geom_vline(xintercept = 1,      # reference line at 1 for OR, 0 for pure coeffs
             linetype = "solid",
             linewidth = 0.2) +
  geom_point(aes(color = model), # point estimate
             size = 2,
             shape = 21#,
             #alpha = 0.5#,
             #position = position_dodge(width = 1)
             ) +
  geom_pointrange(# error bars
                 #height = 0,
                 #aes(color = model),
                 linewidth = 0.5,
                 #position = position_dodge(width = 1)
                 ) +
  scale_x_log10(breaks = scales::trans_breaks("log10", function(x) 10^x),
                labels = scales::trans_format("log10", scales::math_format(.x))) +
  scale_y_discrete(limits=c("Intercept", "Party ID x Strength: none", "Party ID x Strength: Small party", "Party ID x Strength: AfD", "Party ID x Strength: Left", "Party ID x Strength: FDP", "Party ID x Strength: Greens", "Party ID x Strength: SPD", "Att. Immigration: limit", "Att. Immigration: neither nor", "Att. Inequality: don't take measures", "Att. Inequality: no opinion", "Strength of Party ID", "Party ID: none", "Party ID: Small party", "Party ID: AfD", "Party ID: Left", "Party ID: FDP", "Party ID: Greens", "Party ID: SPD", "LR-Ideology", "Religiosity: very","Religiosity: somewhat", "Religiosity: not very", "Residence: East Germany", "Income: high","Income: medium", "Employment: not working", "Employment: studying", "Education", "Gender: female", "Age")) +
  scale_color_manual(limits = c("GLES", "GPT"),
                      values = c("GLES" = "#1e31fa", "GPT" = "#faa32b")) +
  facet_grid(.~party) +
  theme_minimal() +
  labs(
    x = "ß as Odds Ratios (additive effect on log-odds) - only variables where p < 0.05",
    y = "",
    title = "Determinants of Vote Choice According to GLES and GPT \n(Reference: CDU/CSU)") +
  theme(
        #plot.background = element_rect(fill = "white", color = "white"),
        legend.position = "top",
        legend.title = element_blank()
        )


ggsave("model_vote.png", plot_vote_compare, height = 6, width = 8)
```

```{r}
plot_vote_compare
```

See merged PDF / Google Sheet

The null-model predicts higher odds for Non-voting, SPD, AfD and lower odds for the other parties based on GLES data, but higher odds for all parties except small and irregular votes based on GPT data! Confirms descriptive results


# ROBUSTNESS

## TO DO: Imputed vs. non-imputed

## Patterns in missing completions / NA Analysis

### Distribution of NAs across samples

Sample 4 has more NAs than others! 15 on average (not counting S4), but S4 has 27

```{r}
table(mc_GLES2017_final$sample_no, is.na(mc_GLES2017_final$vote_gpt))
```

### Distribution of NAs across individuals

There are 78 individuals with NAs, 9 of which have NAs in 2 samples, resulting in 87 NAs overall

```{r}
gpt_NAs <- data_final_numeric[is.na(data_final_numeric$vote_gpt), "id"]
n_distinct(gpt_NAs) # 78 --> 9 with 2 NAs: 864, 972, 1123, 1425, 1490, 1495, 1655, 1842, 2081
```

#### NAs vs. non-NAs: prompt variables

##### QUESTION:
- Test stat. significance? N = 79 vs. 1827...

```{r}
data_NAs <- data_final_numeric %>%
            group_by(id) %>%
            mutate(missing = ifelse(any(is.na(vote_gpt)), 1, 0)) %>% # mark all IDs with at least 1 NA
            summarise(across(everything(), first)) %>%
            ungroup() %>%
            mutate(missing_2 = ifelse(id == 864 | id == 972 | id == 1123 | id == 1425 | id == 1490 | id == 1495 | id == 1655 | id == 1842 | id == 2081, 1, 0)) # double-NAs

prop.table(table(data_NAs$female, data_NAs$missing),2) # 50/50 among NAs, slightly more females than among non-NAs
prop.table(table(data_NAs$edu, data_NAs$missing),2) # Slightly more better-educated people than among non-NAs
prop.table(table(data_NAs$hhincome, data_NAs$missing),2) # Much fewer people with low income, much more with medium among NAs!
prop.table(table(data_NAs$east, data_NAs$missing),2) # Slightly more people from East Germany among NAs
prop.table(table(data_NAs$religious, data_NAs$missing),2) # NAs less religious
prop.table(table(data_NAs$leftright, data_NAs$missing),2) # less left/right, much more middle
prop.table(table(data_NAs$partyid, data_NAs$missing),2) # less CDU/CSU, SPD, FDP, Left, no Greens/AfD, more small party, MUCH more no party
prop.table(table(data_NAs$partyid_degree, data_NAs$missing),2) # much more weakly! Much less strongly
prop.table(table(data_NAs$inequality, data_NAs$missing),2) # more neutrals, much less "don't act"
prop.table(table(data_NAs$immigration, data_NAs$missing),2) # much fewer foster, more neutrals & limit
prop.table(table(data_NAs$vote, data_NAs$missing),2) # much less CDU/CSU, SPD, more FDP, small party, invalid, no vote (same for Greens & AfD!)
prop.table(table(data_NAs$imputed, data_NAs$missing),2) # much less imputed cases!
```

#### TO DO: Double-NAs

```{r}


```

#### Ineligibility ("did not vote") due to age or other reasons

```{r}
data_novote <- data_final_numeric %>%
  filter(vote_gpt == "Nicht gewählt") %>%
  select(id, age, completion, vote_gpt, vote)

write.csv(data_novote, file = "GPT4PO_novote.csv")

# Manual coding & descriptive analysis of completions
```

# APPENDIX

## Variable Overview TO DO: Export

```{r}
                        #vtable(
                        #       out = "viewer", #change to "csv" with file = ; or "html" for paper export
                              #file = "descriptives.csv",
                        #       class = FALSE,
                        #       missing = TRUE,
                        #       factor.limit = 0,
                        #       char.values = TRUE,
                        #       summ = c("median(x)", "mean(x)", "sd(x)", "nuniq(x)"),
                        #       desc = "omit"
                        #       )
```


## Summary Statistics TO DO: Export

```{r}
data_final_numeric %>% filter(sample_no == 1) %>%
                       select(-c(id, id_sampleno, sample_no, party, prompt,
                                 starts_with(c("completion", "matched", "check_manually",
                                               "manipulated", "resampled")))) %>%
                       mutate(imputed = as.logical(imputed)) %>%
                       sumtable(vars = c("age", "female", "edu", "emp", "hhincome", "east", "religious", "leftright", "partyid", "partyid_degree", "inequality", "immigration", "vote", "imputed"),
                                add.median = TRUE,
                                #out = "csv", file = "summarystats.csv",
                                #title = "Summary Statistics: Prompt Variables",
                                digits = 2
                                )

data_final_numeric %>% select(c(imputed, vote, vote_gpt,
                                starts_with(c("manipulated", "resampled")))) %>%
                       mutate(imputed = as.logical(imputed)) %>%
                       mutate(across(starts_with("manipulated"), as.logical)) %>%
                       mutate(across(starts_with("resampled"), as.logical)) %>%
                       sumtable(vars = c("imputed", "vote", "vote_gpt", "manipulated",
                                         "resampled_1", "manipulated_1",
                                         "resampled_2", "manipulated_2"),
                                add.median = TRUE,
                                #out = "csv", file = "stats_matching.csv",
                                #title = "Summary Statistics: Matching",
                                digits = 2
                                )
```

## Correlation Matrix TO DO

```{r}

```

