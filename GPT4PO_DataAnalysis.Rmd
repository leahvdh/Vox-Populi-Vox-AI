---
title: 'GPT for Public Opinion: Data Analysis'
author: "Leah von der Heyde, Alexander Wenz, Carolina Haensch"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggmosaic)
```

# Shares of correct and incorrect matches

## Tables

```{r}
# Overall
table_matches_overall_c <- table(mc_GLES2017_final$match_vote_outcome)
table_matches_overall_s <- prop.table(table_matches_overall_c)

data_matches_overall_s <- as.data.frame(table_matches_overall_s)
data_matches_overall_s <- data_matches_overall_s %>%
                          mutate(sample = "Overall") %>%
                          rename(match = Var1)

# Per sample
table_matches_counts <- table(mc_GLES2017_final$match_vote_outcome, mc_GLES2017_final$sample_no)
table_matches_shares <- prop.table(table_matches_counts, 2)

data_matches_shares <- as.data.frame(table_matches_shares)
data_matches_shares <- data_matches_shares %>%
                       rename(sample = Var2) %>%
                       rename(match = Var1)
# Together
data_matches_shares_all <- bind_rows(data_matches_overall_s, data_matches_shares)
data_matches_shares_all <- data_matches_shares_all %>%
                           mutate(sample = factor(sample, 
                                  levels = c("Overall", "1", "2", "3", "4", "5"),
                                  labels = c("Overall", "1", "2", "3", "4", "5")))
```

## Plot
```{r}
plot_matches <- ggplot(data_matches_shares_all,
                       aes(x = sample,
                           y = Freq,
                           fill = match)) +
                      geom_bar(stat = "identity", position = "stack") +
                      geom_text(aes(label = paste0(round(Freq*100,1),"%")), 
                                position = position_fill(0.5), color = c(rep(c("white", "black"), 6))) +
                      xlab("Sample") +
                      ylab("") +
                      scale_fill_manual(values = c("FALSE" = "#8F2809", "TRUE" = "#74aa9c"), 
                                        labels = c("wrong", "correct"),
                                        name = "GPT Prediction") +
                      scale_y_continuous(labels = scales::percent) +
                      ggtitle("") +
                      theme_minimal()
plot_matches
```

# Shares of correct and incorrect matches by party vote

## Tables

```{r}
# Across samples
table_matches_parties_s <- prop.table(table(mc_GLES2017_final$vote, mc_GLES2017_final$match_vote_outcome), 1)

# Sample 1
table_matches_parties_s_1 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 1], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 1]), 1)

# Sample 2
table_matches_parties_s_2 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 2], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 2]), 1)

# Sample 3
table_matches_parties_s_3 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 3], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 3]), 1)

# Sample 4
table_matches_parties_s_4 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 4], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 4]), 1)

# Sample 5
table_matches_parties_s_5 <- prop.table(table(mc_GLES2017_final$vote[mc_GLES2017_final$sample_no == 5], mc_GLES2017_final$match_vote_outcome[mc_GLES2017_final$sample_no == 5]), 1)

```

## Plot (across samples, by party)

```{r}
data_matches_parties_s <- as.data.frame(table_matches_parties_s)
data_matches_parties_s <- data_matches_parties_s %>%
                            rename(match = Var2) %>%
                            rename(party = Var1)

data_matches_overall_parties_s <- data_matches_overall_s %>%
                                  rename(party = sample) %>%
                                  mutate(party = factor(party))


data_matches_parties_all <- bind_rows(data_matches_overall_parties_s, data_matches_parties_s)

plot_matches_parties <- ggplot(data_matches_parties_all,
                       aes(x = party,
                           y = Freq,
                           fill = match)) +
                      geom_bar(stat = "identity", position = "stack") +
                      geom_text(aes(label = paste0(round(Freq*100,1),"%")), 
                                position = position_fill(0.5), color = "white") +
                      xlab("Party") +
                      ylab("") +
                      scale_x_discrete(limits = c("Overall", "Bündnis 90/Die Grünen", "CDU/CSU", "Die Linke",
                                                  "SPD", "FDP", "AfD", "Andere Partei", "Nicht gewählt",
                                                  "Ungültig gewählt")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      scale_fill_manual(values = c("FALSE" = "#8F2809", "TRUE" = "#74aa9c"), 
                                        labels = c("wrong", "correct"),
                                        name = "GPT Prediction") +
                      ggtitle("") +
                      theme_minimal()

plot_matches_parties

plot_matches_parties_mosaic <- ggplot(mc_GLES2017_final) + geom_mosaic(aes(x = product(vote), fill=match_vote_outcome)) + theme_mosaic()

```

# Shares of correct and incorrect matches by persona

```{r}
table_matches_ids_s <- prop.table(table(mc_GLES2017_final$id, mc_GLES2017_final$match_vote_outcome), 1)

data_matches_ids_s <- as.data.frame(table_matches_ids_s)
data_matches_ids_s <- data_matches_ids_s %>%
                            rename(match = Var2) %>%
                            rename(id = Var1) %>%
                            pivot_wider(names_from = match,
                                        values_from = Freq,
                                        names_prefix = "match")

prop.table(table(data_matches_ids_s$matchTRUE))

plot_dist_matches <- hist(data_matches_ids_s$matchTRUE,
                                   breaks = c(0, 0.2, 0.4, 0.6, 0.8, 1),
                                   main = "Distribution of correct predictions per persona",
                                   xlab = "Share of correct matches in 5 samples",
                                   ylab = "Frequency")

plot_dist_matches

# Summary: in 41% of cases, GPT is consistently wrong; in 21% of cases, it's consistently correct. In the remaining 38% of cases, it gets a majority of votes right 59% of the time.

```


# Distribution of vote shares GLES vs. GPT

## Tables

```{r}

# GLES
table_vote_overall_s <- prop.table(table(mc_GLES2017_final$vote, useNA = "always"))

# GPT Overall
table_votegpt_overall_s <- prop.table(table(mc_GLES2017_final$vote_gpt, useNA = "always"))

# GPT Sample 1
table_votegpt_s1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 1], useNA = "always"))

# GPT Sample 2
table_votegpt_s1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 2], useNA = "always"))

# GPT Sample 3
table_votegpt_s1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 3], useNA = "always"))

# GPT Sample 4
table_votegpt_s1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 4], useNA = "always"))

# GPT Sample 5
table_votegpt_s1 <- prop.table(table(mc_GLES2017_final$vote_gpt[mc_GLES2017_final$sample_no == 5], useNA = "always"))


```


## Plot

```{r}

#GLES

## Filter the dataset for a specific sample_no
data_vote_1 <- subset(mc_GLES2017_final, sample_no == 1)

## Calculate the relative frequencies of each category
table_vote_freq_1 <- prop.table(table(data_vote_1$vote))

## Sort the categories based on their frequencies
data_vote_freq_1_sorted <- as.data.frame(table_vote_freq_1[order(table_vote_freq_1, decreasing = TRUE)])

data_vote_freq_1_sorted <- data_vote_freq_1_sorted %>%
                           rename(party = Var1) %>%
                           mutate(source = "GLES") %>%
                           mutate(source = as.factor(source)) %>%
                           mutate(T_stderr = NA) %>%
                           rename(freq = Freq)

# Comparing across samples

## Create a new data frame by merging "vote" and "vote_gpt", GLES vote = sample 0
data_vote_long <- mc_GLES2017_final %>%
  group_by(id) %>%
  summarise(sample = c(sample_no, 0),
            vote_new = c(vote_gpt, unique(vote)))


## Create a count table of "vote" and "sample_no"
table_votes_count <- table(data_vote_long$vote_new, data_vote_long$sample)

## Convert the count table to a data frame
data_votes_count <- as.data.frame(table_votes_count)

## Rename the columns
colnames(data_votes_count) <- c("vote", "sample_no", "count")

## Calculate the relative frequencies
data_votes_count$freq <- data_votes_count$count / tapply(data_votes_count$count, data_votes_count$sample_no, sum)[data_votes_count$sample_no]

## Sort the data frame by descending frequency within each sample_no
data_votes_count <- data_votes_count[order(data_votes_count$sample_no, -data_votes_count$freq), ] # doesn't work?

gpt_hues_6 <- c("#FF6100", "#31524B", "#5F9F90", "#74AA9C","#ACCDC5","grey")

## Create the grouped bar plot
plot_shares <- ggplot(data_votes_count, aes(x = reorder(vote, -freq), y = freq, fill = as.factor(sample_no))) +
                      geom_bar(stat = "identity", position = "dodge") +
                      #geom_text(aes(label = paste0(round(freq*100,1),"%")), 
                      #          position = position_dodge(0.9), vjust = 0,
                      #          color = "black") +
                      xlab("Party") +
                      ylab("Vote Share") +
                      scale_fill_manual(values = gpt_hues_6, name = "Sample",
                                        labels = c("GLES", "Sample 1", "Sample 2", 
                                        "Sample 3", "Sample 4", "Sample 5")) +
                      scale_x_discrete(limits = c("CDU/CSU", "SPD", "Bündnis 90/Die Grünen", "FDP", "Die Linke",
                                                  "AfD", "Andere Partei", "Ungültig gewählt",
                                                  "Nicht gewählt")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      ggtitle("") +
                      theme_minimal()

plot_shares

```

# Variance estimation

```{r}
  
# Calculate proportions and its variance for each iteration
sample_proportions <- mc_GLES2017_final %>%
    group_by(sample_no, vote_gpt) %>%
    summarise(n = n(), .groups = "keep") %>%
    ungroup(vote_gpt) %>%
    mutate(prop_estimate = n / sum(n)) %>%
    mutate(prop_variance = prop_estimate * (1 - prop_estimate) / sum(n))

# Calculate the between-imputation (Leah: iteration?) variance and total variance
mean_proportions <- sample_proportions %>%
    group_by(vote_gpt) %>%
    summarise(W = mean(prop_variance), # Within variance (mean)
              mean_prop = mean(prop_estimate),
              B = var(prop_estimate)) %>% # Between variance
    mutate(m = 5,
           T = W + (1 + 1/m) * B,
           T_stderr= sqrt(T)) %>% # total variance (Rubin's rules) 
    arrange(desc(mean_prop))

mean_proportions 
```

## Plot

```{r}
# Adjust GPT
mean_proportions_df <- mean_proportions %>%
                       select(vote_gpt, mean_prop, T_stderr) %>%
                       rename(party = vote_gpt) %>%
                       rename(freq = mean_prop) %>%
                       replace_na(list(party = "no prediction")) %>%
                       mutate(source = "GPT") %>%
                       add_row(party = "Ungültig gewählt", freq = 0, source = "GPT", T_stderr = NA) %>% # omit once fixed in data collection!
                       mutate(party = as.factor(party)) %>%
                       mutate(source = factor(source, levels = c("GLES", "GPT")))
# Adjust GLES
data_vote_freq <- data_vote_freq_1_sorted %>%
                  add_row(party = "no prediction", freq = 0, source = "GLES", T_stderr = NA) %>%
                  mutate(party = as.factor(party)) %>%
                  mutate(source = factor(source, levels = c("GLES", "GPT")))

# Merge GLES & GPT
data_vote_parties <- bind_rows(mean_proportions_df, data_vote_freq)


plot_shares_aggregate <- ggplot(data_vote_parties, aes(x = party,
                                                      y = freq, fill = source)) +
                      geom_bar(stat = "identity", position = "dodge") +
                      geom_text(aes(label = paste0(round(freq*100,1),"%")), 
                                position = position_dodge(0.9), vjust = 0,
                                color = "black") +
                      xlab("Party") +
                      ylab("Vote Share") +
                      scale_x_discrete(limits = c("CDU/CSU", "SPD", "Bündnis 90/Die Grünen", "FDP", "Die Linke",
                                                  "AfD", "Andere Partei", "Ungültig gewählt", "Nicht gewählt",
                                                  "no prediction")) + # reorder categories
                      scale_y_continuous(labels = scales::percent) +
                      scale_fill_manual(limits = c("GLES", "GPT"),
                                        values = c("GLES" = "#FF6100", "GPT" = "#5F9F90"),
                                        name = "Source") +
                      geom_errorbar(aes(x=party, ymin=freq-(1.96*T_stderr), ymax=freq+(1.96*T_stderr)),
                                    width=0.4, colour="#31524B", position = position_dodge(width = 0.9)) +
                      ggtitle("") +
                      theme_minimal()


ggsave("shares_aggregate.png", plot_shares_aggregate, height = 4, width = 11)

plot_shares_aggregate

```

# Correlation 
statt mean in summarize: corr und dann Varianzschätzer

```{r}

```


# Regression Models

## Comparing determinants of vote choice

```{r}

```


## Assessing determinants of match

```{r}
data_final_factors <- mc_GLES2017_final %>%
                      mutate(
    female = factor(female,
                    levels = c("männlich","weiblich"),
                    labels = c("männlich","weiblich")),
    edu = factor(edu,
                 levels = c("keinen Schulabschluss",
                            "einen Hauptschulabschluss",
                            "einen Realschulabschluss",
                            "Abitur",
                            "einen Hochschulabschluss"), 
                 labels = c("keinen Schulabschluss",
                            "einen Hauptschulabschluss",
                            "einen Realschulabschluss",
                            "Abitur",
                            "einen Hochschulabschluss"),
                 ordered = TRUE),
    emp = factor(emp,
                 levels = c("berufstätig",
                            "nicht berufstätig",
                            "in Ausbildung"),
                 labels = c("berufstätig",
                            "nicht berufstätig",
                            "in Ausbildung")),
    hhincome = factor(hhincome,
                      levels = c("niedriges", "mittleres", "hohes"), 
                      labels = c("niedriges", "mittleres", "hohes"),
                      ordered = TRUE),
    east = factor(east,
                  levels = c("Westdeutschland",
                             "Ostdeutschland"),
                  labels = c("Westdeutschland",
                             "Ostdeutschland")),
    religious = factor(religious,
                       levels = c("überhaupt nicht religiös",
                                  "nicht sehr religiös",
                                  "etwas religiös",
                                  "sehr religiös"), 
                       labels = c("überhaupt nicht religiös",
                                  "nicht sehr religiös",
                                  "etwas religiös",
                                  "sehr religiös"),
                       ordered = TRUE),
    leftright = factor(leftright,
                       levels = c("stark links",
                                  "mittig links",
                                  "in der Mitte",
                                  "mittig rechts",
                                  "stark rechts"),
                       labels = c("stark links",
                                  "mittig links",
                                  "in der Mitte",
                                  "mittig rechts",
                                  "stark rechts"),
                       ordered = TRUE),
    partyid = factor(partyid,
                     levels = c("mit der Partei CDU/CSU",
                                "mit der Partei SPD", 
                                "mit der Partei FDP",
                                "mit der Partei Bündnis 90/Die Grünen",
                                "mit der Partei Die Linke",
                                "mit der Partei AfD",
                                "mit einer Kleinpartei",
                                "mit keiner Partei"),
                     labels = c("CDU/CSU",
                                "SPD", 
                                "FDP",
                                "Die Grünen",
                                "Die Linke",
                                "AfD",
                                "Kleinpartei",
                                "keine Partei")),
    partyid_degree = ifelse(partyid_degree == "", "überhaupt nicht", partyid_degree), # NAs to zero
    partyid_degree = factor(partyid_degree,
                            levels = c("überhaupt nicht",
                                       "sehr schwach ",
                                       "ziemlich schwach ",
                                       "mäßig ",
                                       "ziemlich stark ",
                                       "sehr stark "),
                            labels = c("überhaupt nicht",
                                       "sehr schwach",
                                       "ziemlich schwach",
                                       "mäßig",
                                       "ziemlich stark",
                                       "sehr stark"),
                            ordered = TRUE),
    inequality = factor(inequality,
                        levels = c("Maßnahmen ergreifen",
                                   "habe keine Meinung dazu, ob die Regierung Maßnahmen ergreifen sollte",
                                   "keine Maßnahmen ergreifen"),
                        labels = c("Maßnahmen ergreifen",
                                   "habe keine Meinung dazu",
                                   "keine Maßnahmen ergreifen"),
                        ordered = TRUE),
    immigration = factor(immigration,
                         levels = c("erleichtern",
                                    "weder erleichtern noch einschränken",
                                    "einschränken"), 
                         labels = c("erleichtern",
                                    "weder erleichtern noch einschränken",
                                    "einschränken"),
                         ordered = TRUE),
    vote = factor(vote,
                  levels = c("CDU/CSU",
                             "SPD",
                             "Bündnis 90/Die Grünen",
                             "FDP",
                             "Die Linke",
                             "AfD",
                             "Andere Partei",
                             "Ungültig gewählt",
                             "Nicht gewählt"),
                  labels = c("CDU/CSU",
                             "SPD",
                             "Bündnis 90/Die Grünen",
                             "FDP",
                             "Die Linke",
                             "AfD",
                             "Andere Partei",
                             "Ungültig gewählt",
                             "Nicht gewählt"))
                      )

model_match <- glm(match_vote_outcome ~ age + female + edu + emp + hhincome + east + religious + leftright + partyid*partyid_degree + inequality + immigration,
                   data=data_final_factors, family=binomial(link=logit))

summary(model_match)
```

